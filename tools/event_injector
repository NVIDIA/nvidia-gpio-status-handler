#!/usr/bin/env bash

set -o pipefail

################################################################################
# App Constants
#
APPNAME=event_injector
APPVER=0.1

################################################################################
# Definitions
#
DEFUSR=nobody
DEFGRP=nogroup

get_realuser()
{
    local rusr;rusr=`logname 2>/dev/null`
    [ $? -ne 0 ] || [ -z "$rusr" ] && rusr=${LOGNAME}
    [ -z "$rusr" ] && rusr=${USER}
    [ -z "$rusr" ] && rusr=${DEFUSR}
    echo $rusr
}

get_realgroup() # (user)
{
    local usr=$1
    [ -z "$usr" ] && usr=${DEFUSR}
    if [ "${DEFUSR}" = "$usr" ]; then
        echo "${DEFGRP}"
        return 0
    fi
    local grp;grp=`groups "$usr" 2>/dev/null | cut -d' ' -f3`
    [ $? -ne 0 ] || [ -z "$grp" ] && grp=${DEFGRP}
    echo $grp
}

REALUSER=`get_realuser`
REALGROUP=`get_realgroup "${REALUSER}"`
LOGPATH=/tmp/${REALUSER}_${APPNAME}_$$
LOGTMP=tmp.log
LOGAPP=app.log
APPTMP=${LOGPATH}/${LOGTMP}
APPLOG=${LOGPATH}/${LOGAPP}

################################################################################
# Constants
#


################################################################################
# Functions
#
show_help()
{
    echo "A Tool in OpenBMC to Inject Device Event Log to D-Bus, Ver=${APPVER}"
    echo "<usage>"
    echo -e "\t${APPNAME} -p dev_evts.tsv [options]"
    echo "syntax:"
    echo -e "\tscriptTemplate [-p|r]"
    echo "options:"
    echo -e "\t-p PROFILE"
    echo -e "\t\tthe file of the list of necessary event information."
    echo -e "\t-r"
    echo -e "\t\tinject device event log to D-Bus."
    echo
}

### Logging Module
initlog()
{
    [ -d "${LOGPATH}" ] || mkdir -p "${LOGPATH}"
}

log() # (string...)
{
    local opt
    if [ "$1" = "-n" ]; then
        opt="-n"
        shift
    else
        opt=""
    fi
    local msg="`date '+[%Y-%m-%d %H:%M:%S]'` $*"
    #echo $opt $msg
    echo $opt $msg >> ${APPLOG}
}

echo_log() # (string...)
{
    local msg=$*
    echo $msg
    log $msg
}

cleanup()
{
    [ -d "${LOGPATH}" ] || return
    log "Cleanup log files..."
    rm -rf "${LOGPATH}"
    set +o pipefail
}

### Installation Module
DEF_INST_PATH=/usr/bin
APPFLNM=$0
APPBSNM=${APPFLNM##*/}

get_version() # (file)
{
    local ver;ver=`grep -E "^APPVER=" "$1" 2>/dev/null`
    [ $? -ne 0 ] || [ -z "$ver" ] && return 1
    ver=${ver#*=}
    echo $ver
    return 0
}

setup_replace() # (file, var_name, var_new_value)
{
    local fil=$1;shift
    local var_name=$1;shift
    local new_value=$1;shift

    sed -i "s,^${var_name}=.*,${var_name}=${new_value},g" $fil
}

install() # (install_path)
{
    local tgt_dir=$1
    [ -n "$tgt_dir" ] || tgt_dir=$DEF_INST_PATH
    [ -d "$tgt_dir" ] || mkdir -p $tgt_dir

    local rc=0

    local tgt_filename=$tgt_dir/$APPBSNM

    if [ -f "$tgt_filename" ]; then
        local cur_ver=`get_version "$tgt_filename"`
        [ -z "$cur_ver" ] && cur_ver="Unknown"
        local opt
        read -n 1 -p "[$tgt_filename] Exists!
Current Version: $cur_ver
New Version    : $APPVER
Continue? (Y/n)" opt
        echo
        [ ! "$opt" = "n" ] && opt="y"
        if [ "$opt" = "n" ]; then
            echo "Installation Cancelled."
            return 1
        fi
    fi

    echo -n "Copying [$APPFLNM] to [$tgt_dir]..."
    cp -f $APPFLNM $tgt_dir &>/dev/null; rc=$?
    [ "$rc" -ne 0 ] && echo "Failed ($rc)!" && return $rc
    echo "Done."

    echo -n "Setting up installation information..."
    setup_replace "$tgt_filename" DEF_INST_PATH "$tgt_dir" &>/dev/null; rc=$?
    [ "$rc" -ne 0 ] && echo "Failed ($rc)!" && return $rc
    echo "Done."

    echo "Installation Successfully."
    return 0
}

uninstall()
{
    local rc=0
    local tgt_dir=$DEF_INST_PATH

    local opt
    read -n 1 -p "Uninstall [$APPFLNM], version $APPVER? (y/N)" opt
    echo
    [ ! "$opt" = "y" ] && opt="n"
    if [ "$opt" = "n" ]; then
        echo "Uninstallaction Cancelled."
        return 1
    fi

    echo -n "Removing [$APPBSNM] from [$tgt_dir]..."
    rm -f $DEF_INST_PATH/$APPBSNM; rc=$?
    [ "$rc" -ne 0 ] && echo "Failed ($rc)!" && return $rc
    echo "Done."

    echo "Uninstallation Successfully."
    return 0
}

### Event Injection
openbmc_log_severity() # $1: svr_str
{
    [ "$#" -ne 1 ] && echo "[E] need params!" && return 1

    local svr_prefix="xyz.openbmc_project.Logging.Entry.Level"

    local svr_str=${1,,}
    case $svr_str in
        "ok") echo "${svr_prefix}.Notice" ;;
        "warning") echo "${svr_prefix}.Warning" ;;
        "critical") echo "${svr_prefix}.Critical" ;;
        *) return 2;;
    esac

    return 0
}

devp2list() # $1: dev pattern
{
    local devp=$1;shift

    local pref=${devp%%[*}
    local sufx=${devp##*]}
    local mid=${devp##*[}; mid=${mid%]*}

    if [[ $devp =~ .*\[[0-9]+\-[0-9]\].* ]]; then
        local min=${mid%%-*}
        local max=${mid##*-}

        local i
        for ((i=${min}; i<=${max}; i++)); do printf "${pref}%d${sufx}\n" $i; done
        return $?
    fi

    if [[ $devp =~ .*\[.+(,.+)*\].* ]]; then
        for i in ${mid//,/ }; do
            [ -n "$pref" ] && printf "${pref}_" | tr -s '_'
            printf "%s" $i
            [ -n "$sufx" ] && printf "_${sufx}\n" | tr -s '_' || printf "\n"
        done
        return $?
    fi

    echo "${devp}"
    return 0
}

evtdoc2cmdline() # $1: profile
{
    local prf=$1;shift
    local inject=$1;shift

    if [ -z "$prf" ]; then
        echo "[E] No profile provided!"
        return 1
    fi
    if [ ! -f "$prf" ]; then
        echo "[E] [$prf] doesn't exist!"
        return 2
    fi

    local logger_svc="xyz.openbmc_project.Logging"
    local logger_obj="/xyz/openbmc_project/logging"
    local logger_add_entry="xyz.openbmc_project.Logging.Create Create ssa{ss}"
    
    local key_res="xyz.openbmc_project.Logging.Entry.Resolution"

    local rc=0
    local devp_cache
    local line
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        [ "${line:0:1}" = "#" ] && continue

        local devp=`echo "$line" | cut -f1`
        [ "$devp" = "Device" ] && continue # skip the caption
        [ "$devp" = "Non-Interrupt Events" ] && break # FIXME: stop here for now.
        [ -z "$devp" ] && devp=${devp_cache} || devp_cache=$devp
        printf "=%.0s" {0..40};echo

        local event=`echo "$line" | cut -f2`
        local subevent=`echo "$line" | cut -f3`
        # Filter out invalid event
        [ -z "$event" ] && [ -z "$subevent" ] && continue
        [ "${event,,}" = "wip" ] && continue
        [ "${event,,}" = "tbd" ] && continue
        event=${event:3} # remove the "(x)" prefix
        subevent=${subevent:3}

        # replace event with subevent if exists.
        [ -n "$subevent" ] && event=$subevent

        local dev
        echo "`devp2list "$devp"`" | while IFS= read -r dev; do
            # Replace any place holders in the payload
            local DeviceID=$dev # DON'T change [DeviceID] here
            local line_fmt=`eval echo "\"${line//\"/\\\\\"}\""`
            local msg_id=`echo "$line_fmt" | cut -f4`
            local msg_svr=`echo "$line_fmt" | cut -f5`
            local msg_res=`echo "$line_fmt" | cut -f6`
            #local msg_origcond=`echo "$line_fmt" | cut -f7` # Out of scope for QEMU R5 
            local msg_args=`echo "$line_fmt" | cut -f8`

            # Generating the injection cmdline
            local msg="\"$dev $event\""

            local dbus_log_svr;dbus_log_svr=`openbmc_log_severity "$msg_svr" 2>/dev/null`;rc=$?
            [ "$rc" -ne 0 ] && echo "[E] Unknown severity label [$msg_svr], rc=$rc!" && return $rc

            msg="$msg $dbus_log_svr"
            msg="$msg 2" # 4 key-value pairs
            msg="$msg \"REDFISH_MESSAGE_ID\" \"${msg_id}\""
            msg="$msg \"REDFISH_MESSAGE_ARGS\" \"${msg_args}\""
            msg="$msg ${key_res} \"${msg_res}\"" # TBD
            # msg="$msg \"REDFISH_MESSAGE_ORIGCOND\" \"${msg_origcond}\"" # TBD # Out of scope for QEMU R5 

            local cmd="busctl call ${logger_svc} ${logger_obj} ${logger_add_entry} ${msg}"

            # Waiting for Resolution field to be added to Phosphor Logging
            # local cmd="busctl call ${logger_svc} ${logger_obj} ${logger_add_entry} ${msg_res} ${msg}"

            echo $cmd

            if [ ! -z "$inject" ] && [ "$inject" = "true" ]; then
                echo "Injecting Device Event Log ($event) to D-Bus"
                eval $cmd
            fi

        done
    done < "$prf"
}

### Main Module
main() # $*: all args
{
    local prf=''
    local inject=''
    while getopts 'rp:' flag; do
        case "${flag}" in
            p) prf="${OPTARG}" ;;
            r) inject='true' ;;
            *) print_usage
            exit 1 ;;
        esac
    done

    if [ -z "$prf" ]; then
        echo "[E] No profile provided!"
        return 1
    fi
    if [ ! -f "$prf" ]; then
        echo "[E] [$prf] doesn't exist!"
        return 2
    fi
    
    evtdoc2cmdline "$prf" "$inject"

    return 0
}

################################################################################
# MAIN
#
[ $# -ne 0 ] && if grep "^$1()" `which $0` &> /dev/null; then func=$1;shift;$func "$@";exit $?; fi

trap cleanup EXIT
initlog

main $*;rc=$?
[ "$rc" -ne 0 ] && show_help

exit $rc
cleanup
