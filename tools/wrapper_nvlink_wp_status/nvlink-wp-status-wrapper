#!/usr/bin/env bash

# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
#
#  NVIDIA CORPORATION and its licensors retain all intellectual property
#  and proprietary rights in and to this software, related documentation
#  and any modifications thereto.  Any use, reproduction, disclosure or
#  distribution of this software and related documentation without an express
#  license agreement from NVIDIA CORPORATION is strictly prohibited.

set -o pipefail

#
# Define constants
#

APP_VER="0.1"

fullAppName=$( realpath $0 )
dirPath=$( dirname $fullAppName )
appName=${fullAppName#${dirPath}/}

# Special values that, when found in the profile file, will
# assume a dynamic value
DEVICE_INDEX_KEY=dev_index
PAGE_KEY=page

[ -z "${DEVICE_ID_NORM_SCR}" ] && DEVICE_ID_NORM_SCR="device-id-norm.sh"
deviceIdNormScr="${DEVICE_ID_NORM_SCR}"


# Careful with changing this line, undergoes substitution in openbmc recipe
PROFILE_FILE_DIR=${dirPath}
PROFILE_FILE_NAME="nvlink_wp_profile.csv"

# Platform dependent profile.
# Use Case 1:
# In OpenBMC recipe, replace PROFILE_FILE with
# nvlink_profile.csv proper path.
#
# Use Case 2:
# From cmdline, define PROFILE_FILE=<path of nvlink_profile.csv>
# before calling this script to run with custom profile.
[ -z "$PROFILE_FILE" ] && PROFILE_FILE="${PROFILE_FILE_DIR}/${PROFILE_FILE_NAME}"
profilePath="${PROFILE_FILE}"

USAGE="Usage:

  ${appName} [--debug] CMD
  ${appName} [--debug] CMD DEV_NAME
      Use the profile file '${profilePath}' to query SMBPBI.
      First form is for commands which don't require a device name.

  ${appName} (--help|-h)
      Print this help

  ${appName} (--print-params-json | -p)
      Don't call any busctl, just print the parameters calculated
      from the profile file in the json format. For debugging purposes
      only.
"

ERR_USAGE="Wrong number of arguments.

${USAGE}"

BAD_COMMAND=1
NOT_ENOUGH_ARGUMENTS=2
DEVICE_ID_UNRECOGNIZED=3
BAD_DEVICE_ID=4

#
# Define funtions
#

min() {
    local a=$1
    local b=$2
    echo $(( a > b ? b : a ))
}

max() {
    local a=$1
    local b=$2
    echo $(( a > b ? a : b))
}

bound() {
    local val=$1
    local lower=$2
    local upper=$3
    echo $( max ${lower} $( min ${val} ${upper} ) )
}

# Having integer 'x' and a natural number 'n' return a value 'k' fulfilling
#
#   0 <= k < n
#
# such that
#
#   x = n * p + k
#
# for some integer 'p'
mod() {
    local x=$1
    local n=$2
    if (( x >= 0 )); then
        echo $(( x % n ))
    else
        echo $(( n - ((-x - 1) % n) - 1 ))
    fi
}

# Generalize bit shifting to integer numbers
bitshiftLeft() {
    local val=$1
    local bits=$2
    if (( bits >= 0 )); then
        echo $(( val << bits ))
    else
        echo $(( val >> (-bits) ))
    fi
}

extractVal() {
    # Print the number being the result of masking the integer
    # 'value' with 'bits' bitmask encoded in format
    # 'highest:lowest', eg '12:5'
    local value=$1
    local highBound=$2
    # local high=$2
    local low=$3

    startBit=$low
    bitWidth=$(( $highBound - $low ))
    bitMask=$(( (2 ** $bitWidth) - 1 ))
    result=$(( ($value >> $startBit) & $bitMask ))
    echo "${result}"
}

printError() {
    local message=$1
    echo "ERROR: ${message}"
}

printDebug() {
    local message=$1
    if test "${DEBUG}"; then
        echo "DEBUG: ${message}"
    fi
}

printParamsStart() {
    if [[ ${JSON_PARAMS} ]]; then
        echo "{"
    fi
}

atLeastOneElemPrinted=""
printParam() {
    local name=$1
    if [[ ${JSON_PARAMS} ]]; then
        if [[ ${atLeastOneElemPrinted} ]]; then
            echo ","
        fi
        echo -n "\"${name}\" : \"${!name}\""
        atLeastOneElemPrinted=1
    fi
}

printParamsEnd() {
    if [[ ${JSON_PARAMS} ]]; then
        echo
        echo "}"
    fi
}

print() {
    local message=$1
    if [[ -z ${JSON_PARAMS} ]]; then
        echo ${message}
    fi
}

evaluateExpr() {
    local environment=$1
    local expression=$2

    echo $( bash -c "echo \$( ${environment} bash -c 'echo \$(( ${expression} ))' )" )
}

########################### Program start ############################

#
# Args dispatch
#

dispatchOpts="1"
while [[ ${dispatchOpts} ]]; do
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        HELP=$1
        shift
    elif [[ "$1" == "--debug" || "$1" == "-d" ]]; then
        DEBUG=$1
        shift
    elif [[ "$1" == "--print-params-json" || "$1" == "-p" ]]; then
        JSON_PARAMS=$1
        shift
    else
        dispatchOpts=""
    fi
done

if [[ ${HELP} ]]; then
    echo "${USAGE}"
    exit 0
fi

printParamsStart

COMMAND="$1"
shift
#DEVICE_ID="$2"

printDebug "Parameters:"
printDebug "  DEBUG     = '${DEBUG}'"
printDebug "  COMMAND   = '${COMMAND}'"
#printDebug "  DEVICE_ID = '${DEVICE_ID}'"
printDebug

printDebug "Parsing the profile file '${profilePath}'"
while IFS=',' read -r symbol               \
                      profileDeviceIdStems \
                      profileQueryType     \
                      profileDeviceIndex   \
                      profileOpcode        \
                      profileArg1          \
                      profileArg2          \
                      profileElemIndex     \
                      profileElemOffset    \
                      profileElemLength    \
                      profileSubelemLength
do
    printDebug "Checking if command '${COMMAND}' is '${symbol}'..."
    if [[ "${COMMAND}" == "${symbol}" ]]; then
        printDebug "  ...match"

        profileSymbol=${symbol}

        printDebug "Configuration found:"
        printDebug "  profileSymbol        = '${profileSymbol}'"
        printDebug "  profileDeviceIdStems = '${profileDeviceIdStems}'"
        printDebug "  profileQueryType     = '${profileQueryType}'"
        printDebug "  profileDeviceIndex   = '${profileDeviceIndex}'"
        printDebug "  profileOpcode        = '${profileOpcode}'"
        printDebug "  profileArg1          = '${profileArg1}'"
        printDebug "  profileArg2          = '${profileArg2}'"
        printDebug "  profileElemIndex     = '${profileElemIndex}'"
        printDebug "  profileElemOffset    = '${profileElemOffset}'"
        printDebug "  profileElemLength    = '${profileElemLength}'"
        printDebug "  profileSubelemLength = '${profileSubelemLength}'"
        printDebug
        break
    fi

done < ${profilePath}

#
# Exit if no configuration found
#

if test -z "${profileSymbol}"; then
    printError "No entry found in '${profilePath}'\
 for given device '${DEVICE_ID}'\
 and command '${COMMAND}'"
    exit ${BAD_COMMAND}
fi


printDebug "Parsing the applicable device stems: '${profileDeviceIdStems}'"
IFS=';' read -a deviceIdStems <<EOF
${profileDeviceIdStems}
EOF

stemsCount=${#deviceIdStems[@]}
deviceIdsRead=0

environment=
indexesRead=0

printDebug "Dispatching the rest of the script arguments"
for ((i=0; i < stemsCount; i++))
do
    printDebug "Processing argument '$1'"
    deviceId=$1
    shift
    if [[ -z ${deviceId} ]]; then
        >&2 echo "Expected ${stemsCount} device id arguments" \
            "for the command '${profileSymbol}' but only ${i}" \
            "could be read (expected next with stem '${deviceIdStems[i]}')"
        exit ${NOT_ENOUGH_ARGUMENTS}
    else
        printDebug "Parsing the device id '${deviceId}' with '${deviceIdNormScr}'..."
        deviceIdNormOut=$( ${deviceIdNormScr} --ext ${deviceId} ); res=$?

        if (( res != 0 )); then
            >&2 echo "Unrecognized device id '${deviceId}'"
            exit ${DEVICE_ID_UNRECOGNIZED}
        fi

        read argDeviceFullId argDeviceIdStem argDeviceIndexesJoined <<EOF
${deviceIdNormOut}
EOF
        printDebug "  ...done"
        printDebug "  argDeviceFullId        = '${argDeviceFullId}'"
        printDebug "  argDeviceIdStem        = '${argDeviceIdStem}'"
        printDebug "  argDeviceIndexesJoined = '${argDeviceIndexesJoined}'"
        printDebug

        if [[ "${argDeviceIdStem}" != "${deviceIdStems[i]}" ]]; then
            >&2 echo "The stem '${argDeviceIdStem}' of" \
                "the normalized device id '${argDeviceFullId}',"\
                "of the provided in argument device id '${deviceId}'," \
                "doesn't match the expected '${deviceIdStems[i]}'"
            exit ${BAD_DEVICE_ID}
        else

            printDebug "Appending indexes '${argDeviceIndexesJoined}' into evaluation environment"

            read -a argDeviceIndexes <<EOF
${argDeviceIndexesJoined}
EOF

            for argDeviceIndex in ${argDeviceIndexes[@]}
            do
                printDebug "Processing index '${argDeviceIndex}'"
                if ((indexesRead == 0)); then
                    var="x"
                else
                    var="x${indexesRead}"
                fi
                environment="${environment} ${var}=${argDeviceIndex}"
                printDebug "  environment = '${environment}'"
                indexesRead=$(( indexesRead + 1 ))
            done
            printDebug

        fi
    fi
done

printDebug "Done dispatching arguments"
if [[ $1 ]]; then
    printDebug "Ignoring argumet '$1' and any past it"
fi
printDebug

################# Calculate the required parameters ##################

#
# Model description
#

# Values naming convention:
#
#   NOUN_indexIn_NOUN
#   NOUN_size_UNIT
#   NOUN_countIn_NOUN
#   NOUN_offset_UNIT_NOUN

# NOUNs used:
#
#   `elem'      Piece of data continuously placed in `response'
#   `subelem'   The actual information stored in `elem' to be returned
#   `data'      The whole sequence of `elems' accessible through smbpbi calls
#   `word'      The 32-bits long piece of data returned by smbpbi
#   `wordA'     The `word' containing less significant part of `subelem' (if it spans two words)
#   `wordB'     The `word' containing more significant part of `subelem' (if it spans two words)
#   `response'  The two `words' returned by smbpbi ("data out" and "data out extended")
#   `page'      Continuous subsequence of `elems' in `data' which fits into `response'

# NOUNs visualization:
#
#                                                      data
#     <------------------------------------------------------------------------------------------------------>
#                                               page
#                    v-----------------------------------------------------------v
#
#                  +------------word---------------+  +------------word---------------+
#       +------+   | +------+ +------+ +------+    |  | +------+ +------+ +------+    |   +------+   +------+
#  ...  | elem |   | | elem | | elem | | elem |    |  | | elem | | elem | | elem |    |   | elem |   | elem |  ...
#       +------+   | +------+ +------+ +------+    |  | +------+ +------+ +------+    |   +------+   +------+
#                  +-------------------------------+  +-------------------------------+
#
#                  ^------------------------------------------------------------------^
#                                                response
#
#
#    +-------------------elem-----------------------+
#    | +-----------------+ +----------------------+ |
#    | |     subelem     | |       subelem        | |
#    | +-----------------+ +----------------------+ |
#    +----------------------------------------------+
#
# Most of the time an `elem' consists of only one `subelem'
# filling it completely, but that's not the case for
# "nvlink_sublink_width_tx" and "nvlink_sublink_width_rx".


BcW=32
WcO=2

printDebug "Calculating parameters"

printDebug "Evaluating expression '${profileElemIndex}' ('elem_index' column)"
printDebug "  in environment '${environment}'..."
EiD=$( evaluateExpr "${environment}" "${profileElemIndex}" )
printDebug "  ...result: '${EiD}'"

printParam EiD
printDebug "  EiD = '${EiD}'"

# DoO: Data offset (bits) in Output
DoO=${profileElemOffset}
printParam DoO
printDebug "  DoO = '${DoO}'"

# BcE: Bit count in Element
BcE=${profileElemLength}
printParam BcE
printDebug "  BcE = '${BcE}'"

# BcF: Bit count in Subelement
BcF=${profileSubelemLength}
printParam BcF
printDebug "  BcF = '${BcF}'"

# WcS: Word count in Segment
# WcS=ceil(BcE / BcW)
WcS=$(( (BcE + BcW - 1) / BcW ))
printParam WcS
printDebug "  WcS = '${WcS}'"

# BcS: Bit count in Segment
# BcS=WcS * BcW
BcS=$(( WcS * BcW ))
printParam BcS
printDebug "  BcS = '${BcS}'"

# EcS: Element count in Segment
# EcS=floor(BcS / BcE)
EcS=$(( BcS / BcE ))
printParam EcS
printDebug "  EcS = '${EcS}'"

# ScO: Segment count in Output
# ScO=floor(WcO / WcS)
ScO=$(( WcO / WcS ))
printParam ScO
printDebug "  ScO = '${ScO}'"

# EcO: Element count in Output
# EcO=ScO * EcS
EcO=$(( ScO * EcS ))
printParam EcO
printDebug "  EcO = '${EcO}'"

# EiS: Element index in Segment
# EiS=EiD % EcS
EiS=$( mod ${EiD} ${EcS} )
printParam EiS
printDebug "  EiS = '${EiS}'"

# EiO: Element index in Output
# EiO=EiD % EcO
EiO=$( mod ${EiD} ${EcO} )
printParam EiO
printDebug "  EiO = '${EiO}'"

# SiO: Segment index in Output
# SiO=floor(EiO / EcS)
SiO=$(( EiO / EcS ))
printParam SiO
printDebug "  SiO = '${SiO}'"

# PiD: Page index in Data
# PiD=floor(EiD / EcO)
PiD=$(( EiD / EcO ))
printParam PiD
printDebug "  PiD = '${PiD}'"

printDebug

# outputData=$(( 0x12345678 ))
# outputDataExtended=$(( 0x89ABCDEF ))

# printDebug "  outputData         = $( printf '0x%X' ${outputData} )"
# printDebug "  outputDataExtended = $( printf '0x%X' ${outputDataExtended} )"

####################### Build the busctl call ########################

if [[ ${JSON_PARAMS} ]]; then
    outputData=0
    outputDataExtended=0
else

    #
    # Determine the value of arg2
    #

    printDebug "Building busctl command"
    printDebug

    # Add 'page' variable to the environment in which index was evaluated
    buscallEnv="${environment} page=${PiD}"
    
    printDebug "Determining device id"
    printDebug "Evaluating expression '${profileDeviceIndex}' ('device_index' column)"
    printDebug "  in environment '${buscallEnv}'..."
    serverDeviceId=$( evaluateExpr "${buscallEnv}" "${profileDeviceIndex}" )
    printDebug "  ...result: '${serverDeviceId}'"
    printDebug

    printDebug "Determining arg2"
    printDebug "Evaluating expression '${profileArg2}' ('arg2' column)"
    printDebug "  in environment '${buscallEnv}'..."
    arg2=$( evaluateExpr "${buscallEnv}" "${profileArg2}" )
    printDebug "  ...result: '${arg2}'"
    printDebug

    #
    # Build and run the busctl command
    #

    profileAdditionalDataInCnt=0
    profileAdditionalDataBytes=""
    busctlCmd="busctl call xyz.openbmc_project.GpuMgr\
 /xyz/openbmc_project/GpuMgr\
 xyz.openbmc_project.GpuMgr.Server\
 $profileQueryType\
 iyyyau $serverDeviceId $profileOpcode\
 $profileArg1 $arg2\
 $profileAdditionalDataInCnt $profileAdditionalDataBytes"

    printDebug "Calling '${busctlCmd}'..."

    # busctlOutput="(iau) 0 4 0 520094234 25000 25001"
    # rc=0
    busctlOutput=`$busctlCmd`; rc=$?

    #
    # Check the dbus call status
    #

    if [ $rc -ne 0 ]; then
        >&2 echo "ERROR: nvlink query command"
        >&2 echo "${busctlCmd}"
        >&2 echo "failed with exit status ${rc}"
        exit $rc
    else
        printDebug "...success (exit status 0)"
        printDebug "  Output: '${busctlOutput}'"
        printDebug
    fi

    #
    # Dispatch the result and check SMBPBI call status
    #

    regex1='^\(iau\)\s+([0-9]+)(.*)$'
    [[ ${busctlOutput} =~ ${regex1} ]]

    busCallStatus=${BASH_REMATCH[1]}
    rest=${BASH_REMATCH[2]}

    printDebug "Result dispatch 1:"
    printDebug "  busCallStatus = '${busCallStatus}'"
    printDebug "  rest          = '${rest}'"
    printDebug

    if (( $busCallStatus != 0 )); then
        printError "SMBPBI call returned non-zero value '${busCallStatus}'"
        exit 1
    fi

    #
    # Dispatch the actual response
    #

    regex2='^\s+4\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)'
    [[ ${rest} =~ ${regex2} ]]

    returnCode=${BASH_REMATCH[1]}
    smbpbiStatusCode=${BASH_REMATCH[2]}
    outputData=${BASH_REMATCH[3]}
    outputDataExtended=${BASH_REMATCH[4]}

    printDebug "Result dispatch 2:"
    printDebug "  returnCode         = '${returnCode}'"
    printDebug "  smbpbiStatusCode   = '${smbpbiStatusCode}'"
    printDebug "  outputData         = '${outputData}'"
    printDebug "  outputDataExtended = '${outputDataExtended}'"
    printDebug

fi

#
# Calculate the result
#

printDebug "Calculating the result:"

result=0
printDebug "Looping over '${WcS}' words"
for ((WiS=0; WiS < WcS ; WiS++))
do
    # WiS: Word index in Segment

    printDebug "----------------"
    printDebug "  WiS = '${WiS}'"
    # FoW: Subelement offset (bits) in Word
    FoW=$(( BcE * EiS - WiS * BcW + DoO ))
    if (( WiS == 0 )); then
        printParam FoW
    fi
    printDebug "  FoW = '${FoW}'"
    # FbW: Subelement bound (bits) in Word
    FbW=$(( FoW + BcF ))
    if (( WiS == 0 )); then
        printParam FbW
    fi
    printDebug "  FbW = '${FbW}'"

    # CoW: Chunk offset (bits) in Word
    CoW=$( bound ${FoW} 0 ${BcW} )
    if (( WiS == 0 )); then
        printParam CoW
    fi
    printDebug "  CoW = '${CoW}'"
    # CbW: Chunk bound (bits) in Word
    CbW=$( bound ${FbW} 0 ${BcW} )
    if (( WiS == 0 )); then
        printParam CbW
    fi
    printDebug "  CbW = '${CbW}'"

    # WoR: Word offset (bits) in Result
    WoR=$(( CoW - FoW ))
    if (( WiS == 0 )); then
        printParam WoR
    fi
    printDebug "  WoR = '${WoR}'"

    # WiO: Word index in Output
    WiO=$(( SiO * WcS + WiS ))
    if (( WiS == 0 )); then
        printParam WiO
    fi
    printDebug "  WiO = '${WiO}'"

    if (( WiO == 0 )); then
        word=${outputData}
    elif (( WiO == 1 )); then
        word=${outputDataExtended}
    else
        >&2 echo "Unsupported word index: '${WiO}'"
        exit 1
    fi
    printDebug "  word = $( printf '0x%X' ${word} )"

    chunkW=$(extractVal ${word} ${CbW} ${CoW})
    printDebug "  chunkW = $( printf '0x%X' ${chunkW} )"
    chunkO=$(bitshiftLeft ${chunkW} ${WoR} )
    printDebug "  chunkO = $( printf '0x%X' ${chunkO} )"
    result=$(( result | chunkO ))
    printDebug "  result = $( printf '0x%X' ${result} )"
done


if [[ -z ${JSON_PARAMS} ]]; then
    echo ${result}
fi

printParamsEnd

exit 0
