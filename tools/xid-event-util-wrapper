#!/usr/bin/env bash

set -o pipefail

APP_NAME="xid-event-util-wrapper"
APP_VER="1.0"

show_help()
{
    echo "A wrapper for xid events for GPUs and NVSwitches, ver=${APP_VER}."
    echo "<usage>"
    echo "  ${APP_NAME} [-dry-run] <device_id> <oob_property> <xid_data>"
    echo
    echo "<options>"
    echo "  --dry-run         - Only print ${APP_NAME} cmdline."
    echo
    echo "  device_id         - Device ID: For NVSwitch->HGX_NVSwitch_[0-3], For GPU->HGX_GPU_SXM_[1-8]"
    echo
    echo "  oob_property      - OOB properties Supported: gpu.xid.event, nvswitch.Sxid.event"
    echo
    echo "  xid_data          - XID Data Types Supported: XidId, TextMessage, XidTextMessage"
    echo
}


## MAIN
DRY_RUN=0

## -dry-run just prints the xid-event-util-wrapper command line
if [ "$1"  = "--dry-run" ]; then
   DRY_RUN=1
   shift
fi

if [ $# -ne 3 ]; then
    show_help
    exit 1
fi

deviceName=$1
device=$(echo "$1" | grep -Eo '[0-9]+$')

if [ -z $device ]; then
  echo "Invalid Device $1. Exiting!"
  show_help
  exit 1
fi

if [[ $1 == *"GPU"* ]]; then
   device_id=$(($device-1))
   event="XID"
   eventsPendingProp="gpu.events.PendingRegister"
else
  device_id=$device
  event="SXID"
  eventsPendingProp="nvswitch.events.PendingRegister"
fi

if [ -z $device_id ] || [ $device_id -eq -1 ]; then
  echo "Unsupported GPU Device $device_id. Exiting!"
  show_help
  exit 1
fi

cmdline="busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData isi $device_id \"$2\" 1"

if [ "$DRY_RUN" -eq 1 ]; then
    echo $cmdline
    exit 0
fi

# DEM fail counter is used to keep track of failed fetch DEM calls
# If we are not able to read DEM for maxDemFailCounter times, we would exit
demFailCounter=0
maxDemFailCounter=20

# Sample Output: (isau) 0 "GPU Driver Event Message - xid Event : 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 57 6f 72 6c 64 00 00 00" 2 3120605958 2881141434
# Indexes:                                                        1   2  3  4           5           6  
# Index Meaning:
#          1 record size    32-bit words
#          2 xid id         8-bits
#          3 flags          8-bits
#          4 seqNumber      32-bits
#          5 timeStamp      32-bits
#          6 textMessage[0] Null terminated
function fetchDem()
{
  local output;output=$(eval $cmdline)
  rc=$?
  [ "$rc" -eq 0 ] || return 1

  # output='(isau) 0 "GPU Driver Event Message - xid Event : 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00" 2 3120605958 2881141434'
  # Cut on delimiter ' ' to get the data after the ':'
  # output -> 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00
  output=`echo $output | cut -d'"' -f 2 | sed 's/.*\: //'`

  # if no data is found, we return XID: 0 No Data found!!
  # Increase the DEM fail counter
  # Return exit code 2
  if [ -z "$output" ]; then
    echo "20 00 00 ba ba ba ba ab ab ab ab 4e 6f 20 64 61 74 61 20 66 6f 75 6e 64 21"
    return 2
  fi

  echo "$output"

  return 0
}

# Create a phosphor log, using Phosphor-logging Create method
function createLog()
{
  xid="_XID"
  createlogCmd="busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Logging.Create Create ssa{ss} \""$event" Error\" \"xyz.openbmc_project.Logging.Entry.Level.Error\" 3 \"REDFISH_MESSAGE_ARGS\" \""$deviceName" Driver Event Message, "$event": "$1"\" \"REDFISH_MESSAGE_ID\" \"ResourceEvent.1.0.ResourceErrorsDetected\" \"namespace\" \""$deviceName$xid"\""
  # createlogCmd="busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Logging.Create Create ssa{ss} \"$event Error\" \"xyz.openbmc_project.Logging.Entry.Level.Error\" 3 \"REDFISH_MESSAGE_ARGS\" \"$deviceName Driver Event Message, $event: $1\" \"REDFISH_MESSAGE_ID\" \"ResourceEvent.1.0.ResourceErrorsDetected\" \"namespace\" \"$deviceName$xid\""
  bash -c "$createlogCmd"
  rc=$?
  return $rc
  
}

# Convert Hex "48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00"
# To ASCII "Hello World"
function convertHexToAscii()
{
  local res
  ascii=""
  for char in $@
  do
    res=`printf "\x$char"`
    ascii="$ascii$res"
  done
}

function readEventsPendingRegister()
{
  local eventsPendingcmd="busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData isi $device_id \"$eventsPendingProp\" 1"
  pendingRegisterOut=$(eval $eventsPendingcmd)
  pendingRegister=`echo $pendingRegisterOut | cut -d'"' -f 2 | sed 's/.*\: //'`
  if [ -z "$pendingRegister" ];then
    echo $pendingRegisterOut
    return 1
  fi
  pendingRegister=$(( 16#$pendingRegister ))
  echo $(( $pendingRegister & 0x4 ))
  return 0
}

eventPendingRegister=$(readEventsPendingRegister)
rc=$?
[ "$rc" -eq 0 ] || exit $rc

# 1. Read DEM
# 2. Extract required information from DEM
# 3. Create a log entry for Phosphor-logging
# 4. Sleep 1s - to give SMBPBI some time to update EventsPendingRegister
# 5. Read EventsPendingRegister
# 6. If EventsPendingRegister DEM bit is set repeat Step #1 else exit
while [ $eventPendingRegister -ne 0 ]
do
  # Check for the arguments
  case $3 in

    XidId)

      dem=$(fetchDem)
      rc=$?
      # Reset DEM fail counter
      [ "$rc" -eq 0 ] && demFailCounter=0
      [ "$rc" -eq 1 ] && exit $rc
      [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))
      # Return XID ID or index 2 from the output
      result=`echo $dem | cut -d ' ' -f 2`
      result=$(( 16#$result ))
      ;;

    TextMessage)

      dem=$(fetchDem)
      rc=$?
      # Reset DEM fail counter
      [ "$rc" -eq 0 ] && demFailCounter=0
      [ "$rc" -eq 1 ] && exit $rc
      [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))
      # Return Text Message or index 6 from the output
      result=`echo $dem | cut -d ' ' -f12- | sed 's/00//g'`
      convertHexToAscii $TextMessage
      result="$ascii"
      ;;

    XidTextMessage)
    
      dem=$(fetchDem)
      rc=$?
      # Reset DEM fail counter
      [ "$rc" -eq 0 ] && demFailCounter=0
      [ "$rc" -eq 1 ] && exit $rc
      [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))
      # Return XID ID or index 2 from the output
      XidId=`echo $dem | cut -d ' ' -f 2`
      XidId=$(( 16#$XidId ))

      # Return Text Message or index 6 from the output
      TextMessage=`echo $dem | cut -d ' ' -f12- | sed 's/00//g'`
      # TextMessage=`echo -n $TextMessage | xxd -r -p`
      convertHexToAscii $TextMessage

      # Concatinate XidID and Text Message
      result="$XidId $ascii"
      ;;

    *)
      show_help
      exit -1
      ;;
  esac
  createLog "$result"
  rc=$?
  [ "$rc" -eq 0 ] || exit $rc

  if [ $demFailCounter -gt $maxDemFailCounter ]; then
    exit 1
  fi
  
  sleep 1s

  eventPendingRegister=$(readEventsPendingRegister)
  rc=$?
  [ "$rc" -eq 0 ] || exit $rc

done

exit 0
