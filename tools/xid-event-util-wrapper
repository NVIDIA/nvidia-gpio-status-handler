#!/usr/bin/env bash

set -o pipefail

APP_NAME="xid-event-util-wrapper"
APP_VER="1.0"

show_help()
{
    echo "A wrapper for xid events for GPUs and NVSwitches, ver=${APP_VER}."
    echo "<usage>"
    echo "  ${APP_NAME} [--dry-run] <device_id> <platform_device_id> <oob_property> <xid_data>"
    echo "  ${APP_NAME} [--dry-run] --test-event-log <device_id> <platform_device_id> <oob_property> <xid_data>"
    echo "  ${APP_NAME} [--dry-run] --monitor-from-file <file_name>"
    echo
    echo "<options>"
    echo "  --dry-run           - Only print ${APP_NAME} cmdline."
    echo
    echo "  device_id           - Device ID: Common device ID, in form of [DeviceType]_[DeviceID].  For example NVSwitch_2 or GPU_7"
    echo
    echo "  platform_device_id  - Platform Device ID: Device ID on platform level used to identify module in Redfish or DBus. For example HGX_GPU_SXM_1."
    echo
    echo "  oob_property        - OOB properties Supported: gpu.xid.event, nvswitch.Sxid.event"
    echo
    echo "  xid_data            - XID Data Types Supported: XidId, TextMessage, XidTextMessage"
    echo
    echo "  --monitor-from-file - monitor a list of <device_id> <oob_property> <xid_data> from <file_name>"
    echo "  --test-event-log    - just creates the event log and exits, useful to see the EventLog and the notification"
echo
}


# Sample Output: (isau) 0 "GPU Driver Event Message - xid Event : 17 4a 00 00 52 00 00 00 3e 9d 00 00 4e 56 4c 69 6e 6b 3a 20 66 61 74 61 6c 20 65 72 72 6f 72 20 64 65 74 65 63 74 65 64 20 6f 6e 20 6c 69 6e 6b 20 31 31 28 30 78 30 2c 20 30 78 30 2c 20 30 78 30 2c 20 30 78 31 30 30" 2 3120605958 2881141434
# Bytes:                                                          1   2  3  4  5           9          13
# Bytes Meaning:
#          1 record size    32-bit words
#          2 xid id         8-bits
#          3 flags          8-bits
#          4 xidExt         8-bits
#          5 seqNumber      32-bits(Little Endian)
#          9 timeStamp      32-bits(Little Endian)
#          13 textMessage[0] Null terminated
function fetchDem()
{
  local output;output=$(eval $cmdline)
  rc=$?
  [ "$rc" -eq 0 ] || return 1

  # output='(isau) 0 "GPU Driver Event Message - xid Event : 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00" 2 3120605958 2881141434'
  # Cut on delimiter ' ' to get the data after the ':'
  # output -> 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00
  output=`echo $output | cut -d'"' -f 2 | sed 's/.*\: //'`

  # if no data is found, we return XID: 0 No Data found!!
  # Increase the DEM fail counter
  # Return exit code 2
  if [ -z "$output" ]; then
    echo "20 00 00 ba ba ba ba ab ab ab ab 4e 6f 20 64 61 74 61 20 66 6f 75 6e 64 21"
    return 2
  fi

  echo "$output"

  return 0
}

# Converts the first argument string into Little Endian output
# e.g. Convert "52 00 00 00" to "00000052"
function convertToLittleEndian()
{
  little_endian_hex=$(echo $1 | awk '{for(i=NF;i>=1;i--) printf "%s ", $i; print ""}' | sed 's/ //g')

  echo "$little_endian_hex"

  return 0
}

# Create a phosphor log, using Phosphor-logging Create method
function createLog()
{
  xid="_XID"
  msg_arg="$1"
  # Cut out any prefixes that came with the platform name for use in the logs.  For example, for platform device name
  # HGX_GPU_SXM_1, we want the log name to be GPU_SXM_1, cutting out everything before the device type, which in this
  # case is "GPU".
  device_log_name=$(echo ${platform_device_name} | awk -F\\${device_type} -v dev=${device_type} '{print dev$2}')
  # Replace "," with ";" from all the XID messages
  # "," are used to split message args, "," in a XID Message would increase the MessageArgs count to be greater than 2
  msg_arg=${msg_arg//,/;}
  # Replace "=" with ":" from all the XID messages
  # Refer bug: https://nvbugs/4204066
  msg_arg=${msg_arg//=/:}
  createlogCmd="\
  busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Logging.Create Create ssa{ss} \""$event" Error\"
  \"xyz.openbmc_project.Logging.Entry.Level.Critical\" 7
  \"xyz.openbmc_project.Logging.Entry.Resolution\" \"Regarding XID documentation and further actions please refer to https://docs.nvidia.com/deploy/xid-errors/index.html\"
  \"REDFISH_MESSAGE_ARGS\" \""${device_log_name}" Driver Event Message, "$msg_arg"\"
  \"REDFISH_MESSAGE_ID\" \"ResourceEvent.1.0.ResourceErrorsDetected\"
  \"namespace\" \"${device_log_name}${xid}\"
  \"EVENT_NAME\" \"$event\"
  \"DEVICE_NAME\" \"${device_log_name}\"
  \"REDFISH_ORIGIN_OF_CONDITION\" \"/xyz/openbmc_project/inventory/system/chassis/${platform_device_name}\"
  "

  if [ $DRY_RUN -eq 1 ]; then
    echo  "$createlogCmd"
    rc=$?
  else
    eval $createlogCmd
    rc=$?
  fi
  return $rc
  
}

# Convert Hex "48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00"
# To ASCII "Hello World"
# The null character '00' identifies the end-of-string
function convertHexToAscii()
{
  local res
  ascii=""
  for char in $@
  do
    [ "$char" = "00" ] && break
    res=`printf "\x$char"`
    ascii="$ascii$res"
  done
}

function readEventsPendingRegisterProperty()
{
  local pendingRegisterOut=$(busctl get-property xyz.openbmc_project.GpuMgr "/xyz/openbmc_project/inventory/system/chassis/${platform_device_name}" xyz.openbmc_project.com.nvidia.Events.PendingRegister EventsPendingRegister)
  local pendingRegister=$(echo "$pendingRegisterOut" | awk '{print $2}')
  if [ -z "$pendingRegister" ];then
    echo $pendingRegisterOut
    return 1
  fi
  echo $(( $pendingRegister & 0x4 ))
  return 0
}

function readEventsPendingRegisterCoreAPI()
{
  local eventsPendingcmd="busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData isi $device_id \"$eventsPendingProp\" 1"
  local pendingRegisterOut=$(eval $eventsPendingcmd)
  local pendingRegister=`echo $pendingRegisterOut | cut -d'"' -f 2 | sed 's/.*\: //'`
  if [ -z "$pendingRegister" ];then
    echo $pendingRegisterOut
    return 1
  fi
  pendingRegister=$(( 16#$pendingRegister ))
  echo $(( $pendingRegister & 0x4 ))
  return 0
}

function set_globals()
{
  # Global variables based on input information, used by other functions

  # From the Common Device ID, derive the device type ie GPU or NVSwitch
  # and the Device ID, which is 0-based
  device_type=$(echo "$1" | cut -d '_' -f 1)
  device_id=$(echo "$1" | grep -Eo '[0-9]+$')

  platform_device_name=$2
  gpumgr_property=$3
  gpumgr_opcode=$4

  if [ -z ${device_id} ] || [ -z ${device_type} ]; then
    echo "Unsupported device $1. Exiting!"
    show_help
    return 1
  fi

  if [[ ${device_type} == "GPU" ]]; then
    event="XID"
    eventsPendingProp="gpu.events.PendingRegister"
  elif [[ ${device_type} == "NVSwitch" ]]; then
    event="SXID"
    eventsPendingProp="nvswitch.events.PendingRegister"
  else
    echo "Unsupported device type ${device_type}. Exiting!"
    show_help
    return 1
  fi

  return 0
}

# function
function main()
{
  if [ $# -ne 4 ]; then
    show_help
    return 1
  fi

  # DEM fail counter is used to keep track of failed fetch DEM calls
  # If we are not able to read DEM for maxDemFailCounter times, we would exit
  local demFailCounter=0
  local maxDemFailCounter=20

  # Set some global variables such as device name and type based on input
  set_globals "$@"
  local set_globals_rc=$?
  if [ "$set_globals_rc" -ne 0 ]; then
    echo "Failed to set device variables for device $1. Exiting!"
    return 1
  fi

  cmdline="busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData isi ${device_id} \"${gpumgr_property}\" 1"

  if [ "$DRY_RUN" -eq 1 ]; then
      echo $cmdline
      return 0
  fi


  eventPendingRegister=$(readEventsPendingRegisterProperty)
  rc=$?
  [ "$rc" -eq 0 ] || return $rc

  # If the D-Bus property says the EventsPendingRegister is asserted,
  # confirm with deviceCoreAPI read (prevent logging "No data found!" XIDs
  # due to the D-Bus property not being refreshed by the next check).
  if [ $eventPendingRegister -ne 0 ]; then
    eventPendingRegister=$(readEventsPendingRegisterCoreAPI)
    rc=$?
    [ "$rc" -eq 0 ] || return $rc
  fi

  # 1. Read DEM
  # 2. Extract required information from DEM
  # 3. Create a log entry for Phosphor-logging
  # 4. Sleep 1s - to give SMBPBI some time to update EventsPendingRegister
  # 5. Read EventsPendingRegister
  # 6. If EventsPendingRegister DEM bit is set repeat Step #1 else exit
  while [ $eventPendingRegister -ne 0 ]
  do
    # Check for the arguments
    case ${gpumgr_opcode} in

      XidId)

        dem=$(fetchDem)
        rc=$?
        # Reset DEM fail counter
        [ "$rc" -eq 0 ] && demFailCounter=0
        [ "$rc" -eq 1 ] && return $rc
        [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))
        # Return XID ID or index 2 from the output
        result=`echo $dem | cut -d ' ' -f 2`
        result=$(( 16#$result ))
        ;;

      TextMessage)

        dem=$(fetchDem)
        rc=$?
        # Reset DEM fail counter
        [ "$rc" -eq 0 ] && demFailCounter=0
        [ "$rc" -eq 1 ] && return $rc
        [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))
        # Return Text Message or index 6 from the output
        result=`echo $dem | cut -d ' ' -f13- | sed 's/00//g'`
        convertHexToAscii $TextMessage
        result="$ascii"
        ;;

      XidTextMessage)

        dem=$(fetchDem)
        rc=$?
        # Reset DEM fail counter
        [ "$rc" -eq 0 ] && demFailCounter=0
        [ "$rc" -eq 1 ] && return $rc
        [ "$rc" -eq 2 ] && demFailCounter=$(($demFailCounter+1))

        # Read XID ID or byte 2 from the DEM
        XidId=`echo $dem | cut -d ' ' -f 2`
        # Convert Hex to Decimal
        XidId=$(( 16#$XidId ))

        # Read flags or byte 3 from DEM
        XidFlags=`echo $dem | cut -d ' ' -f 3`

        XidIdExt=`echo $dem | cut -d ' ' -f 4`
        # Convert Hex to Decimal
        XidIdExt=$(( 16#$XidIdExt ))

        XidIdFull=$(( $XidIdExt*1000 + $XidId ))

        # Read Sequence Number or byte 4-7 from DEM
        XidSeqNum=`echo $dem | cut -d ' ' -f 5-8`
        XidSeqNum=$(convertToLittleEndian "$XidSeqNum")
        # Convert Hex to Decimal
        XidSeqNum=$(( 16#$XidSeqNum ))

        # Read XID Timestamp or byte 8-11 from DEM
        XidTime=`echo $dem | cut -d ' ' -f 9-12`
        XidTime=$(convertToLittleEndian "$XidTime")
        # Convert Hex to Decimal
        XidTime=$(( 16#$XidTime ))
        # Convert epoche TimeStamp to HumanReadable format
        XidTime=`date -d @$XidTime`

        # Read Text Message or byte 12-END from the DEM
        TextMessage=`echo $dem | cut -d ' ' -f13-`
        convertHexToAscii $TextMessage

        # Concatinate the information read above
        result="[$XidTime][$XidSeqNum][$XidFlags] $event $XidIdFull $ascii"
        ;;

      *)
        show_help
        return 1
        ;;
    esac
    createLog "$result"
    rc=$?
    [ "$rc" -eq 0 ] || return $rc

    if [ $demFailCounter -gt $maxDemFailCounter ]; then
      return 1
    fi

    sleep 1s

    eventPendingRegister=$(readEventsPendingRegisterCoreAPI)
    rc=$?
    [ "$rc" -eq 0 ] || return $rc

  done
}


function monitor_main()
{
  local devices_file="$1"
  #echo "monitor from file mode"
  if [ ! -f "$devices_file" ]; then
    >&2 echo "<3>Error: [$devices_file] not found!"
    return 2
  fi
  local devices_to_check=$(cat "$devices_file")
  if [ -z "$devices_to_check" ]; then
    # file is empty, nothing to do
    return 0
  fi
  local failed_device_rc=0
  for device_string in $devices_to_check; do
    #echo "$device_string"
    local devname=$(echo "$device_string" | cut -f1 -d,)
    local platformdevname=$(echo "$device_string" | cut -f2 -d,)
    local propname=$(echo "$device_string" | cut -f3 -d,)
    local opcode=$(echo "$device_string" | cut -f4 -d,)
    main "$devname" "$platformdevname" "$propname" "$opcode"
    local device_rc=$?
    if [ "$device_rc" -ne 0 ]; then
      >&2 echo "<3>Error: check for [$devname $platformdevname $propname $opcode] failed, rc=$device_rc"
      failed_device_rc=$device_rc
    fi
  done
  #return $failed_device_rc
  # README: returing 1 is needed for the script to exit with rc=1 in monitor mode,
  # which is used by the systemd unit file to ensure the service does not eventually
  # get marked as failed and stop restarting.
  if [ "$failed_device_rc" -ne 0 ]; then
    return 1
  else
    return 0
  fi
}


function test_event_creation_notfication()
{
   set_globals "$@"
   local XidTime="Sun Apr 12 12:47:07 UTC 1970"
   local XidSeqNum="10944768"
   local XidFlags="00"
   local event="XID"
   local XidId="43"
   local ascii="dCh 00000008"
   local result="[$XidTime][$XidSeqNum][$XidFlags] $event $XidId $ascii"
   createLog "$result"
   return $?
}


## MAIN
DRY_RUN=0

## -dry-run just prints the xid-event-util-wrapper command line
if [ "$1"  = "--dry-run" ]; then
   DRY_RUN=1
   shift
fi


if [ "$1" = "--test-event-log" ]; then
   shift
   test_event_creation_notfication "$@"
   test_event_creation_rc=$?
   if [ "$test_event_creation_rc" -ne 0 ]; then
     echo "Test event log creation failed."
     exit $test_event_creation_rc
   fi
fi


if [ "$1"  = "--monitor-from-file" ]; then
  # README: returing 1 (which monitor_main does) is needed for the script to exit
  # with rc=1 in monitor mode, which is used by the systemd unit file to ensure
  # the service does not eventually get marked as failed and stop restarting.
  if [ "$#" -ne 2 ]; then
    >&2 echo "<3>Wrong number of arguments in monitor mode!"
    exit 2
  fi
  if [ ! -f "$2" ]; then
    >&2 echo "<3>Path to devices file is not a file! (specified: $2)"
    exit 2
  fi
  monitor_main "$2"
  monitor_rc=$?
  exit $monitor_rc
fi

main "$@"
rc=$?
exit $rc
