#!/usr/bin/env bash

set -o pipefail

APP_NAME="xid-event-util-wrapper"
APP_VER="0.1"

show_help()
{
    echo "A wrapper for xid events for GPUs and NVSwitches, ver=${APP_VER}."
    echo "<usage>"
    echo "  ${APP_NAME} [-dry-run] <device_id> <oob_property> <xid_data>"
    echo
    echo "<options>"
    echo "  --dry-run         - Only print ${APP_NAME} cmdline."
    echo
    echo "  device_id         - Device ID: For NVSwitch->HGX_NVSwitch_[0-3], For GPU->HGX_GPU_SXM_[1-8]"
    echo
    echo "  oob_property      - OOB properties Supported: gpu.xid.event, nvswitch.Sxid.event"
    echo
    echo "  xid_data          - XID Data Types Supported: XidId, TextMessage, XidTextMessage"
    echo
}


## MAIN
DRY_RUN=0

# GPU device names "GPU_SXM_[1-8]" does not follow the conventional device id sequence [1-8] nor [0-7]
#  "GPU_SXM_1" : 4
#  "GPU_SXM_2" : 5
#  "GPU_SXM_3" : 6
#  "GPU_SXM_4" : 7
#  "GPU_SXM_5" : 0
#  "GPU_SXM_6" : 1
#  "GPU_SXM_7" : 2
#  "GPU_SXM_8" : 3
#   GPU_SXM_N  ->  0 1 2 3 4 5 6 7 8
gpu_device_name=( -1 4 5 6 7 0 1 2 3 )

## -dry-run just prints the xid-event-util-wrapper command line
if [ "$1"  = "--dry-run" ]; then
   DRY_RUN=1
   shift
fi

device=$(echo "$1" | grep -Eo '[0-9]+$')

if [ -z $device ]; then
  echo "Invalid Device $1. Exiting!"
  show_help
  exit 1
fi

if [[ $1 == *"GPU"* ]]; then
   device_id=${gpu_device_name[$device]}
else
  device_id=$device
fi

if [ -z $device_id ] || [ $device_id -eq -1 ]; then
  echo "Unsupported GPU Device $device_id. Exiting!"
  show_help
  exit 1
fi

cmdline="busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData isi $device_id \"$2\" 1"

# Sample Output: (isau) 0 "GPU Driver Event Message - xid Event : 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 57 6f 72 6c 64 00 00 00" 2 3120605958 2881141434
# Indexes:                                                        1   2  3  4           5           6  
# Index Meaning:
#          1 record size    32-bit words
#          2 xid id         8-bits
#          3 flags          8-bits
#          4 seqNumber      32-bits
#          5 timeStamp      32-bits
#          6 textMessage[0] Null terminated

if [ "$DRY_RUN" -eq 1 ]; then
    echo $cmdline
    exit 0
fi

if [ $# -ne 3 ]; then
    show_help
    exit 1
fi

output=$(eval $cmdline)
rc=$?
[ "$rc" -eq 0 ] || exit $rc

# output='(isau) 0 "GPU Driver Event Message - xid Event : 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00" 2 3120605958 2881141434'
# Cut on delimiter ' ' to get the data after the ':'
# output -> 06 ab 00 ba ba ba ba ab ab ab ab 48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00
output=`echo $output | cut -d'"' -f 2 | sed 's/.*\: //'`

[ -z "$output" ] && echo "No data found." && exit 0

# Convert Hex "48 65 6c 6c 6f 20 57 6f 72 6c 64 00 00 00"
# To ASCII "Hello World"
function convertHexToAscii()
{
  local res
  ascii=""
  for char in $@
  do
    res=`printf "\x$char"`
    ascii="$ascii$res"
  done
}

# Check for the arguments
case $3 in

   XidId)
    # Return XID ID or index 2 from the output
    result=`echo $output | cut -d ' ' -f 2`
    result=$(( 16#$result ))
    ;;

  TextMessage)
    # Return Text Message or index 6 from the output
    result=`echo $output | cut -d ' ' -f12- | sed 's/00//g'`
    convertHexToAscii $TextMessage
    result="$ascii"
    ;;

  XidTextMessage)
    # Return XID ID or index 2 from the output
    XidId=`echo $output | cut -d ' ' -f 2`
    XidId=$(( 16#$XidId ))

    # Return Text Message or index 6 from the output
    TextMessage=`echo $output | cut -d ' ' -f12- | sed 's/00//g'`
    # TextMessage=`echo -n $TextMessage | xxd -r -p`
    convertHexToAscii $TextMessage

    # Concatinate XidID and Text Message
    result="$XidId $ascii"
    ;;

  *)
    show_help
    exit -1
    ;;
esac

echo $result
exit 0
