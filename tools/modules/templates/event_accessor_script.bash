#!/bin/bash
# This script is generated by event_validation.py, be aware that changes will be lost!

SERVICE_GPUMGR=xyz.openbmc_project.GpuMgr
SERVICE_GPIO_HANDLER=xyz.openbmc_project.GpioStatusHandler
SERVICE_GPU_OOB_RECOVERY=xyz.openbmc_project.GpuOobRecovery
DBUS_CALL_ARGS="$SERVICE_GPUMGR /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server"
DBUS_CALL_GET_ARGS="$DBUS_CALL_ARGS DeviceGetData isi"
DBUS_CALL_SET_ARGS="$DBUS_CALL_ARGS DeviceSetData isu"
DBUS_CALL_CLEAR_ARGS="$DBUS_CALL_ARGS  DeviceClearData is"
DBUS_CALL_CLEAR_PASS_THROUGH_FPGA="$DBUS_CALL_ARGS clearPassthroughFpga"
DBUS_CALL_SET_PASS_THROUGH_FPGA="$DBUS_CALL_ARGS setPassthroughFpga is"
DBUS_CALL_SET_GPU_XID_EVENT_STRING="$DBUS_CALL_ARGS setGpuXidEventString s"
DBUS_OBJECT_MAPPER_GET_OBJECT="xyz.openbmc_project.ObjectMapper /xyz/openbmc_project/object_mapper xyz.openbmc_project.ObjectMapper GetObject sas"

CURRENT_INJECTED_SERVICE_FILE=/tmp/.current_injected_service

# used to clear line message
big_space="                                                                                             "

## global variables
gl_property_value=""
gl_property_type=""
gl_new_property_value=""
gl_old_property_value=""
gl_rc=0
gl_script_rc=0
gl_total_comands=0  # will be set as the total intended commands
gl_counter_commands=0 # counter for commands being executed
gl_injections=0  # successful injections
gl_current_logging_entries=0
gl_previous_logging_entries=""
gl_injection_only=0
gl_failures=0
gl_error_file=/tmp/.event_error_$$
gl_cmd_line_device=""
gl_cmd_line_event=""
gl_cmd_line_device_index=""
gl_original_cmd_line_device_index=""
gl_cmd_line_keep_existing_logs=0
gl_cmd_line_list_events=0
gl_cmd_line_property=""
gl_cmd_line_debug=0
gl_is_single_injection=0 # 1 means is single injection
gl_single_injection_state=0  ## 0 not inserted, 1 = insert
gl_cmd_line_markdown=0
gl_markdown_file=""
AML_INJECTOR_CURRENT_DEVICE_INDEX=""
MAPFILE=/tmp/.mapfile_$$
TIMESTAMP_INJECTION_STARTED=0            ## control time between insert failure and restore
WAIT_TIME_FOR_RELASE_INJECTION_DATA=90
FAILURES_FILE=/tmp/.not_injected_$$
NO_MESSAGE_ARGS_FILE=/tmp/.no_message_args
INVALID_VALUE_MESSAGE_ARGS_FILE=/tmp/.invalid_message_args
INVALID_VALUE_TELEMETRIES_FILE=/tmp/.invalid_telemetries
MCTP_WRAPPER_FILE_PARAM=/tmp/.mctp_param
CUR_OUTPUT_FILE=/tmp/.curl_outpupt
CUR_STATUS_FILE=/tmp/.curl_status
CUR_PRINTING_ENABLE=1
gl_busctl_cmd_counter=0
gl_bustl_cmd_set_failure_title="Failure preparation commands"
gl_bustl_cmd_unset_failure_title="Failure clearing commands"
gl_current_bustcl_title=$gl_bustl_cmd_set_failure_title
gl_current_curl_output_title=""
gl_delete_logs_once=0
gl_device_core_API_index=0;  ## a variable always used for BUSCTL commands regarding device-index
gl_cmd_line_unique_event=0
gl_cmd_do_not_clear_property=0
gl_cmd_print_additional_data=0
gl_use_clean_environment=0
gl_no_set_failure_state=0
gl_unique_events=0

DIR_SAVE_ENTRIES="/tmp/injected"
DIR_SAVE_ENTRIES_ALREADY_FOUND="$DIR_SAVE_ENTRIES/already_found"
REDFISH_ENTRIES_URI="http://127.0.0.1:80/redfish/v1/Systems/HGX_Baseboard_0/LogServices/EventLog/Entries"
REDFISH_CHASSIS_URI="http://127.0.0.1:80/redfish/v1/Chassis"

CURL_CMD="/tmp/oobaml/bin/curl -i"
gl_log_id=0  ## entry to be generated for the firt busctl command
DRY_RUN=0

ALREADY_INSERTED_ATTEMPTS=40     ## times looking back for an event at phosphor logging entries
ALREADY_INSERTED_SLEEP=3
FIRST_INSERTED_ATTEMPTS=50
ERROR_VALUE_CONTENT="Value_Not_Available"
INJECTIONS_REPORT=/tmp/injections_summary_report.txt

help()
{
   echo
   echo " -l|--list-events           just list current 'device event' list"
   echo " -D|--debug                 adds few debug messages"
   echo " -k|--keep-existent-logs    do not remove phosphor log entries at beginning"
   echo " -d|--device <device>       a device defined in event_info.json such as GPU, HMC, etc"
   echo " -e|--event <event-name>    the event as defined in event_info.json (use double quotes)"
   echo " -i|--device-index <index>  plus --device and --event it sets the 'single injection' use index zero when there is no range in the 'device'"
   echo " -p|--property <prop-name>  performs injections on all events that has that DBUS property, e.g., I2C3_ALERT"
   echo " -m|--markdown              only for 'single injection' generates markdown output suitable to create documents, inside '/tmp/md' directory"
   echo " -u|--unique-event          run only one occurrence from an event (the first one) other range expansions are ignored"
   echo " -n|--do-not-clear-property does not clear 'properties state' before setting the suitable property value, works for 'boolean' and 'numeric' properties used in bitmasks"
   echo " -E|--use-clean-environment do not control GpuMgr call returns"
   echo " -S|--no-set-failure-state  do not set failure state before performing bustcl commands"
   echo " -A|--additional-data       print phosphor logging AdditionalData field"
   echo " -h|--help                  shows the help"
   echo
}

while [ "$1" != "" ]; do
    case "$1"  in
        --dry-run)   DRY_RUN=1;;
        -n|--inject-only)         # do not log for logs in phosphor logging
                     DRY_RUN=0
                     gl_injection_only=1;;
        -d|--device) shift; gl_cmd_line_device="$1";;
        -e|--event) shift; gl_cmd_line_event="$1";;
        -k|--keep-existent-logs) gl_cmd_line_keep_existing_logs=1;;
        -l|--list-events) gl_cmd_line_list_events=1;;
        -i|--device-index) shift; gl_cmd_line_device_index="$1"
                                  gl_original_cmd_line_device_index="$1";;
        -p|--property) shift; gl_cmd_line_property="$1";;
        -D|--debug) gl_cmd_line_debug=1;;
        -m|--markdown) gl_cmd_line_markdown=1;;
        -u|--unique-event) gl_cmd_line_unique_event=1;;
        -n|--do-not-clear-property) gl_cmd_do_not_clear_property=1;;
        -E|--use-clean-environment) gl_use_clean_environment=1;;
        -S|--no-set-failure-state) gl_no_set_failure_state=1;;
        -A|--additional-data) gl_cmd_print_additional_data=1;;
        -h|--help) help; exit 0;;
    esac
    shift
done

if [ $DRY_RUN -eq 1 ]; then
   debug; debug running in DRY-RUN mode...; debug ... ; sleep 2
fi

## when specified only --device and --event the user can pass -D to enable debug
if [ $gl_cmd_line_debug -eq 0 -a "$gl_cmd_line_device_index" = "" ]; then
    gl_cmd_line_debug=1
fi

if [ "$gl_cmd_line_device_index" != "" -a "$gl_cmd_line_event" != "" ]
    then
       gl_is_single_injection=1
fi

debug()
{
   [ $gl_cmd_line_debug -eq 0 ] && return
   echo "$@"
}

print()
{
   [ $gl_cmd_line_debug -eq 1 ] && return
   echo "$@"
}

set_global_device_core_API_index() #1 = current index
{
  gl_device_core_API_index=$1
  if [[  $DEVICE =~ "GPU" ]]
  then
     gl_device_core_API_index=$[ $1 -1] # convert 1-8 => 0-7
  else
     gl_device_core_API_index=$1
  fi
}

endBusctlMarkDown()
{
  if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
  then
     echo  "|"  >> "$gl_markdown_file"
     gl_busctl_cmd_counter=0
  fi
}

## always print bustcl commands on the screen
## if --markdown is active, also prints saves in the markdown file
printBusctl()
{
   echo "$@"
   if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
   then
      if [ $gl_busctl_cmd_counter -eq 0 ] ## create table
      then
         echo >> "$gl_markdown_file"
         echo    "|$gl_current_bustcl_title|"    >> "$gl_markdown_file"
         echo    "|:-----------------------|"    >> "$gl_markdown_file"
         echo -n "|$@"                           >> "$gl_markdown_file"
      else
         echo -n "<br>$@"                        >> "$gl_markdown_file"
      fi
      gl_busctl_cmd_counter=$[ $gl_busctl_cmd_counter + 1 ]
   fi
}

createMarkDownForEvent()
{
   device=$1
   event="$2"
   print "$device \"$event\""
   if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
   then
      mkdir -p /tmp/md 2> /dev/null
      gl_markdown_file="/tmp/md/${device}_\"${event}\".md"
      echo "## $device \"$event\"" > "$gl_markdown_file"
      echo                        >> "$gl_markdown_file"
      echo "|Command line|"       >> "$gl_markdown_file"
      echo "|:--------|"          >> "$gl_markdown_file"
      echo "|./test_AML.sh inject --device $device --event \"$event\" --device-index $gl_cmd_line_device_index|"  >> "$gl_markdown_file"
   fi
}

createMarkDownForFileContent() # $1=file
{
    echo >> "$gl_markdown_file"
    echo    "|$gl_current_curl_output_title|" >> "$gl_markdown_file"
    echo    "|:-----------------------|"      >> "$gl_markdown_file"
    first_line=0
    save_ifs=$IFS
    IFS=''
    while  read -r line; do
      out=`echo $line | tr -d '\n' | tr -d '\r' | sed -e 's/ /\&nbsp;/g'`
      if [ "$out" != "" ]
      then
         if [ $first_line -eq 0 ]
         then
            first_line=1
            echo -n "|$out"     >> "$gl_markdown_file"
         else
            echo -n "<br>$out"  >> "$gl_markdown_file"
         fi
      fi
    done < $1
    IFS=$save_ifs
    echo "|" >> "$gl_markdown_file"
}

createMapKey()
{
   key=`echo $* | md5sum | cut -f1 -d ' '`
   echo $key
}

existsMapKey() # 0 does not exist
{
    local key=`createMapKey $*`
    exists=`egrep "^${key}" $MAPFILE 2> /dev/null`
    if [ $? -eq 0 ]  ## exists
    then
         return 1
    fi
    return 0
}

insertMapKey()
{
  local key=`createMapKey $*`
  existsMapKey $*
  if [ $? -eq 0 ]
  then
      echo $key >> $MAPFILE
  fi
}

getService() # $1 = object path $2 = interface
{
   local obj=$1
   local intf=$2
   service=`busctl call $DBUS_OBJECT_MAPPER_GET_OBJECT ${obj} 1 ${intf} 2>/dev/null | awk '{print $3}' | tr -d '"'`
   if [ "$service" = "" ]; then
      if [ "$1" = "/xyz/openbmc_project/GpioStatusHandler" ]; then
         service=$SERVICE_GPIO_HANDLER
      elif [ "$1" = "/xyz/openbmc_project/GpuOobRecovery" ]; then
      service=$SERVICE_GPU_OOB_RECOVERY
      else
         service=$SERVICE_GPUMGR
      fi
   fi
   echo -n $service > $CURRENT_INJECTED_SERVICE_FILE
   echo $service
}


change_digit()
{
   local digit=$1
   if [ "$digit" = "9" ]; then
      digit=8
   else
      digit=$[ $digit + 1 ]
   fi
   echo $digit
}

change_string()
{
   local value="$gl_property_value"
   [ "$METHOD" = "not_equal" ] && value="${METHOD_VALUE}"
   ## 1 change last digit if that exists, example "PCIeTypes.Gen5" becomes "PCIeTypes.Gen6"
   local last_character="${value: -1}"
   if [[ $last_character =~ [0-9] ]]; then
      digit=`change_digit $last_character`
      ret=${value%?}$digit
      if [ "$ret" = "$gl_property_value" ]
      then
         digit=`change_digit $digit`
         ret=${value%?}$digit
      fi
   fi
   if [ "$ret" = "" ]; then
     ret=`date +%s`
   fi
   echo $ret
}

calculate_number()
{
  result=`echo ${1%\.*}`
  rest=$[ $result % 2]
  if [ $rest -eq 0 ]; then
     result=$[ $result * 2 ]
  else
     result=$[ $result + 1]
  fi
  echo $result
}


change_number() # $1 = value to change
{
  local result=${gl_property_value};
  if [ "$METHOD" = "equal" -o  "$METHOD" = "not_equal" ]; then
      result=${METHOD_VALUE}
  fi
  if [ "$result" = "0" ]; then
      result=1
  fi
  result=`calculate_number $result`
  if [ "$result" = "${gl_property_value}" ]; then
      result=`calculate_number $result`
  fi
  echo $result
}

latest_looging_entry()
{
    [ $gl_injection_only -eq 1 ] && return 0
    latest_entry=0
    for entry_value in  $(busctl tree xyz.openbmc_project.Logging | grep /xyz/openbmc_project/logging/entry/ | awk -F / '{ print $NF}' 2> $gl_error_file)
    do
       entry=${entry_value//[!0-9]/}
       [ "$entry" != "" -a $entry -gt $latest_entry ] && latest_entry=$entry
    done
    echo $latest_entry
}

property_get() #1=object_path $2=interface, $3=property_name
{
    gl_property_value=""
    gl_property_type=""
    local cmd="busctl get-property `getService $1 $2`  $@"
    printBusctl $cmd
    local get_value=$(eval $cmd 2> $gl_error_file)
    if [ $? -ne 0 -o "$get_value" = "" ]; then
        gl_rc=1
    else
        debug " $get_value"
        gl_property_value=$(echo $get_value | awk '{print $NF}' | tr -d '\"' 2> $gl_error_file )
        gl_property_type=$(echo $get_value | awk '{print $1}' 2> $gl_error_file)
        [ "$gl_property_value" = "" -o "$gl_property_type" = "" ] && gl_rc=1
    fi
    return $gl_rc
}


change_value_method() #1=value to change
{
    case "$METHOD" in
       "bitmask") gl_new_property_value=$[ ( ${gl_property_value} + 1 ) | ${METHOD_VALUE} ];;
       "lookup")  gl_new_property_value=${METHOD_VALUE};;
       *)         gl_new_property_value=`change_number`;;
    esac
}


clear_property_state() # $1=value $@=others
{
   if [ $gl_cmd_do_not_clear_property -eq 0 ]
   then
      local clear_value="$1"
      shift
      local save_method="$METHOD"
      export METHOD="force"
      local save_method_value=${METHOD_VALUE}
      METHOD_VALUE="$clear_value" property_set "$@"
      export METHOD_VALUE="$save_method_value"
      export METHOD="$save_method"
   fi
}

property_set_method() #1=object_path $2=interface, $3=property_name
{
    gl_new_property_value=""
    gl_old_property_value=$gl_property_value
    if [ "$METHOD" = "bitmask" ]
    then
         export METHOD="force"
         if [ "$gl_property_value" != "0" ]; then
            local save_method_value=${METHOD_VALUE}
            clear_property_state 0 $@
            METHOD_VALUE=$save_method_value
         fi
         ## leave method as force to put the right value
    elif [ "$METHOD" = "lookup" ]
    then
        local save_method_value=${METHOD_VALUE}
        METHOD="add" METHOD_VALUE="1" property_set "$@"
        gl_rc=$?
        gl_property_value=$gl_new_property_value
        METHOD="lookup"
        METHOD_VALUE="$save_method_value"
    fi

    if [ "$gl_property_type" = "b" ] ## handle boolean as special case
    then
          if [[ $gl_old_property_value =~ true ]]; then
              gl_new_property_value="false"
          else
              gl_new_property_value="true"
          fi
          clear_property_state $gl_new_property_value $@
    else
          local method_equal_or_not_equal=0
          [ "$METHOD" = "equal" -o "$METHOD" = "not_equal" ] && method_equal_or_not_equal=1
          # Main call to property_set
          [ $gl_cmd_do_not_clear_property -eq 0 -o $method_equal_or_not_equal -eq 0 ] && property_set "$@"
    fi

    # extra call to property_set if necessary
    if [ $gl_rc -eq 0 ]; then
       if [ "$METHOD" = "equal" -a "$gl_new_property_value" != "${METHOD_VALUE}" ]
       then
            gl_old_property_value="" # force set
            gl_new_property_value=${METHOD_VALUE}
            METHOD="force" property_set "$@"
       fi
       if [ "$METHOD" = "not_equal" -a "$gl_new_property_value" = "${METHOD_VALUE}" ]
       then
            ## force it as string to set back the old value
            METHOD="force"  METHOD_VALUE="$gl_old_property_value"  property_set "$@"
       fi
    fi
    return $gl_rc
}


property_set() #1=object_path $2=interface, $3=property_name
{

    if [ "$METHOD" = "force" ]; then ## force is internal only
        gl_new_property_value=${METHOD_VALUE}
    else
       if [ "$gl_old_property_value" != "" ]; then # allow bypassing this logic
          case $gl_property_type in
               b) ;; # do nothing itw i will be used only when "$METHOD" = "force"
               s|as)   gl_new_property_value=`change_string`
                    [ "$METHOD" = "equal" ] && gl_new_property_value=${METHOD_VALUE}
                  sleep 1
                  ;;
              ## that should work for integers and double types
               *)   change_value_method;
          esac
       fi
    fi

    ocurr=""
    [ "${gl_property_type:0:1}" = "a" ] && ocurr="1"

    cmd="busctl set-property `getService $1 $2`  $@ $gl_property_type $ocurr '$gl_new_property_value'"
    printBusctl $cmd
    [ $DRY_RUN -eq 1 ] && return
    eval $cmd 2> $gl_error_file
    gl_rc=$?
    if [ $gl_rc -eq 0 -a  $gl_injection_only -eq 1 ]; then
       gl_injections=$[ $gl_injections + 1 ]
    fi
    return $gl_rc
}


getAssertedDevice() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 2 | tail -1
   fi
}


getAssertedEvent() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 1
   fi
}

getAssertedMessageArgs() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 3 | tail -1
   fi
}

getAssertedTelemetries() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 4 | tail -1
   fi
}

getOriginOfCondition() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 5 | tail -1
   fi
}

getSelfTestResults()
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 6 | tail -1
   fi
}

matchDeviceAndEvent() # $1=entryid to check, #2 optional the object path
{
    local device=""
    local event=""
    local messageArgs=""
    local telemetries=""
    local origin_of_condition=""
    local selftest_results=""
    local entry_file_name=`printf %03d $1`
    local entry_additional_data_file="${entry_file_name}_additional_data"
    if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
        event=`cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 1`
    else
        local additionalData=$(busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$1 xyz.openbmc_project.Logging.Entry AdditionalData 2>/dev/null)
        if [ "$additionalData" != "" ]; then
            device=$(echo $additionalData | awk -F 'namespace='  '{print $2}' | tr -d \")
            messageArgs=$(echo $additionalData | awk -F REDFISH_MESSAGE_ARGS= {'print $2}' | awk -F \" '{print $1}')
            telemetries=$(echo $additionalData | awk -F '}}]},' {'print $2}' | awk -F \"DEVICE_NAME '{print $1}'  | tr -d '}\\')
            origin_of_condition=$(echo $additionalData | awk -F 'REDFISH_ORIGIN_OF_CONDITION=' '{print $2}' | awk -F \" '{print $1}' )
            local sf_results=$(echo $additionalData | awk -F test-case-total '{print $2}' | awk -F \}\} '{print $1}' | tr -d \" | tr -d \\)
            selftest_results="test-case-total${sf_results}"
        fi
        if [ "$device" != "" ]; then
            event=$(busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$1 xyz.openbmc_project.Logging.Entry Message 2>/dev/null | cut -f2-90 -d' ' | tr -d \")
            echo "$event"   > $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$device" >> $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$messageArgs"  >> $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$telemetries"  >> $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$origin_of_condition" >> $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$selftest_results"    >> $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$additionalData" > $DIR_SAVE_ENTRIES/$entry_additional_data_file
        else
            touch $DIR_SAVE_ENTRIES/$entry_file_name
            return
        fi
    fi

    if [ "$event" = "$EVENT" ]; then
       device=`getAssertedDevice $1`
       local device_to_compare=$DEVICE
       while [ "`echo $device_to_compare | grep -E '[0-9]$'`" != "" -o ${device_to_compare: -1} = "_" ]; do
           device_to_compare=${device_to_compare:0:-1}
       done
       if [ $# -eq 2 ]; then # parameter 2 passed , object path
          object=$(echo $2 | awk -F / '{print $NF}')
          if [[ "$object" == "$DEVICE"* ]]; then
              device_to_compare=$object
          fi
       fi
       if [[ "$device" == "$device_to_compare"* ]]; then
           echo $1 ## correct entry id
       else
          if [[ $device_to_compare =~ $device ]]; then
            echo $1 ## correct entry id
          fi
       fi
    fi
}

verifyInjection()
{
    local interactions=$FIRST_INSERTED_ATTEMPTS
    local logid="" # more then one event can be created
    print "Waiting for the Injection, it may take some time ..."
    while [ "$logid" = "" -a $interactions -gt 0 ]; do
       debug -ne "waiting for the event, trying at most $interactions times to get a new EventLogId (sleep=$ALREADY_INSERTED_SLEEP) ...\r"

       sleep $ALREADY_INSERTED_SLEEP
       local new_logging_entries=$(latest_looging_entry)
       local expected_logging_entry=$[ $gl_current_logging_entries + 1 ]
       if [ $new_logging_entries -gt $gl_current_logging_entries ]; then
          while [ "$logid" = "" -a $expected_logging_entry -le $new_logging_entries ]; do
               logid=$(matchDeviceAndEvent $expected_logging_entry $1)
               expected_logging_entry=$[$expected_logging_entry + 1]
          done
       fi
       interactions=$[ $interactions - 1 ]
    done
    if [ "$logid" != "" ]; then
       debug -ne "${big_space} ${big_space} ${big_space} \r"
       gl_log_id=$logid
       gl_single_injection_state=1
       showStatus "created EventLogId [ $logid ]"
    else
       gl_rc=1
       showStatus 'busctl commands worked but Event NOT created'
    fi
}

showStatus()
{
    status='injected'
    if [ $gl_rc -ne 0 ]; then
        status='failed'
        gl_failures=$[ gl_failures + 1 ]
        print "FAILED injection for DEVICE='$DEVICE' EVENT='$EVENT'"
        debug "    [$gl_counter_commands/$gl_total_comands] DEVICE='$DEVICE' EVENT='$EVENT'" >> $FAILURES_FILE
    else
        gl_injections=$[ $gl_injections + 1 ]
    fi
    error_msg=$(cat $gl_error_file 2> /dev/null)
    message="[debug: $gl_counter_commands/$gl_total_comands] $status DEVICE='$DEVICE' EVENT='$EVENT' : '$1' '$error_msg'"
    debug $message
    [ "$status" = "injected" -a $gl_is_single_injection -eq 0 ] &&  print_and_check_asserted_device_content $gl_log_id
}

getDeviceFromAdditionalData() #$1 = entry id
{
  addData=`busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$entry xyz.openbmc_project.Logging.Entry AdditionalData 2>/dev/null | cut -f3-550 -d' '`


    device=`echo $addData | awk -F 'namespace='  '{print $2}' | tr -d \"`
}

wait_single_injection_to_restore_environment()
{
   if [ $TIMESTAMP_INJECTION_STARTED -ne 0 ]; then
         timestamp=`date +%s`
         wait_time=$[ $timestamp - $TIMESTAMP_INJECTION_STARTED ]
         TIMESTAMP_INJECTION_STARTED=0
         if [ $wait_time -lt $WAIT_TIME_FOR_RELASE_INJECTION_DATA ]; then
            debug "waiting $wait_time seconds to let process other events"
            sleep $wait_time
         fi
   fi
}


clear_deviceCore_API_defaults() ## means do not set Failure state
{
   if [ $gl_use_clean_environment -eq 0 ]
   then
      ## force return 0 to all calls to " busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData"
      CMD="busctl call $DBUS_CALL_ARGS setDeviceDataForAll u 0" >/dev/null
      printBusctl $CMD
      eval $CMD
      # clear return for mctp-error-detection that calls PassthroughFpga iyyyau 0 0xb1 0x81 0 0
      CMD="busctl call $DBUS_CALL_CLEAR_PASS_THROUGH_FPGA"
      printBusctl $CMD
      eval $CMD >/dev/null
   fi
}

clear_Core_API_property()
{
   if [ $gl_no_set_failure_state -eq 0 ]
   then
      CMD="busctl call $DBUS_CALL_CLEAR_ARGS $gl_device_core_API_index $INJECTION_PARAM"
      printBusctl $CMD
      eval $CMD > /dev/null
   fi
}

restore_deviceCore_API_defaults() ## means set Failure State
{
   if [ $gl_use_clean_environment -eq 0 ]
   then
      # also restore  mctp-error-detection
      CMD="busctl call $DBUS_CALL_ARGS clearDeviceDataForAll" >/dev/null
      printBusctl $CMD
      eval $CMD
   fi
}


set_failure_state()
{
   [ $DRY_RUN -eq 1 -o $gl_is_single_injection -eq 0 ] && return

   if [ $gl_delete_logs_once -eq 0 -a $gl_cmd_line_keep_existing_logs -eq 0 ]
   then
        CMD="busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll"
        printBusctl $CMD
        eval $CMD >/dev/null
        gl_delete_logs_once=1
   fi

   TIMESTAMP_INJECTION_STARTED=`date +%s`

   clear_deviceCore_API_defaults

   CMD="echo -n \"$AML_INJECTOR_CURRENT_DEVICE_INDEX $DEVICE $AML_INJECTOR_CURRENT_INJECTION_PARAM\"  > $MCTP_WRAPPER_FILE_PARAM"
   printBusctl $CMD
   eval $CMD

   if [ "$AML_INJECTOR_CURRENT_INJECTION" = "CMDLINE" ]
   then
      read -r command args < <(echo $INJECTION_PARAM)
      if [ "$command" = "mctp-error-detection" ]
      then
         CMD="busctl call $DBUS_CALL_SET_PASS_THROUGH_FPGA $gl_device_core_API_index $DEVICE"
         printBusctl  $CMD
         eval $CMD
      fi
   elif [ "$AML_INJECTOR_CURRENT_INJECTION" = "DeviceCoreAPI" ]
   then
      [ "$INJECTION_CHECK_VALUE" = "" ] && INJECTION_CHECK_VALUE=1
      [ "$INJECTION_CHECK" = "not_equal" ] && INJECTION_CHECK_VALUE=$[ $INJECTION_CHECK_VALUE + 1]
      if [ "$INJECTION_CHECK" != "" -a $INJECTION_PARAM = "gpu.xid.event" ]
      then
            if [ $gl_no_set_failure_state -eq 0 ]
            then
               CMD="busctl call $DBUS_CALL_SET_GPU_XID_EVENT_STRING \"$INJECTION_CHECK_VALUE\""
               printBusctl $CMD
               eval $CMD > /dev/null
            fi
      fi
      if [ $gl_no_set_failure_state -eq 0 ]
      then
         CMD="busctl call $DBUS_CALL_SET_ARGS $gl_device_core_API_index $INJECTION_PARAM $INJECTION_CHECK_VALUE"
         printBusctl $CMD
         eval $CMD > /dev/null
      fi
      if [ $gl_cmd_line_debug -eq 1 ]
      then
         CMD="busctl call  $DBUS_CALL_GET_ARGS $gl_device_core_API_index $INJECTION_PARAM 1"
         printBusctl $CMD
         eval $CMD
      fi
   fi ## it is CMDLINE

}


remove_curl_temp_files()
{
    /bin/rm -f $CUR_OUTPUT_FILE $CUR_STATUS_FILE
}


execute_curl_commmand()
{
  CMD="$CURL_CMD $@"
  debug $CMD

  eval $CMD 1>$CUR_STATUS_FILE 2>/dev/null
  ok=`grep '200 OK' $CUR_STATUS_FILE | grep HTTP`
  ret=1
  if [ "$ok" != "" ]
  then
     ret=0
     grep -v "^[A-Z]"  $CUR_STATUS_FILE > $CUR_OUTPUT_FILE
     if [ $CUR_PRINTING_ENABLE -ne 0 ]
     then
        cat $CUR_OUTPUT_FILE
     fi
     if [ $gl_cmd_line_markdown -eq 1 ]
     then
         createMarkDownForFileContent $CUR_OUTPUT_FILE
     fi
  fi
  if [ $CUR_PRINTING_ENABLE -ne 0 ]
  then
     remove_curl_temp_files
  fi
  CUR_PRINTING_ENABLE=1  ## always set default
  return $ret
}

check_Value_Not_Available()
{
   if [[ "$1" =~ "$ERROR_VALUE_CONTENT" ]]
   then
      return 1 ## match
   fi
   return 0
}

save_content_message_into_file() # $1 =log_id, $2=device, $3=event $4=file
{
   echo "   Entry id=$1 DEVICE=$2 EVENT=\"$3\"" >> $4
}

print_and_check_asserted_device_content()
{
    local redfish_output_origin_of_condition=""
    # look for originOfCondition in Redfish output
    if [ -s "$CUR_OUTPUT_FILE" ]
    then
        redfish_output_origin_of_condition=$(grep '"OriginOfCondition":' $CUR_OUTPUT_FILE  -A1 | grep odata.id | awk '{print $NF}' | tr -d \")
    fi
    local log_id=$1
    event=`getAssertedEvent $log_id`
    device=`getAssertedDevice $log_id`
    messageArgs=`getAssertedMessageArgs $log_id`
    telemetries=`getAssertedTelemetries $log_id`
    originOfCondition=`getOriginOfCondition $log_id`
    selftest_results=`getSelfTestResults $log_id`
    asserted_message="EntryId=$log_id; assertedDevice='$device'; event='$event'; REDFISH_MESSAGE_ARGS='$messageArgs'; REDFISH_ORIGIN_OF_CONDITION='$originOfCondition'; OriginOfCondition='$redfish_output_origin_of_condition'; selftest_results='$selftest_results'; telemetries='$telemetries'"
    if [ $gl_is_single_injection -eq 1 ]; then
       print $asserted_message
    else
       debug $asserted_message
    fi
    if [ -s "$CUR_OUTPUT_FILE" ]
    then
        cat "$CUR_OUTPUT_FILE"
        remove_curl_temp_files
    fi
    ## check event content
    check_Value_Not_Available "$messageArgs"
    [ $? -eq 1 ] && save_content_message_into_file $log_id $device "$event" $INVALID_VALUE_MESSAGE_ARGS_FILE
    check_Value_Not_Available "$telemetries"
    [ $? -eq 1 ] && save_content_message_into_file $log_id $device "$event" $INVALID_VALUE_TELEMETRIES_FILE
    local message_content=1
    if [ "$messageArgs" = "" ]
    then
        message_content=0
    elif [[ "$messageArgs" =~ "''" ]]
    then
        message_content=0
    elif [[ "$messageArgs" =~ "\"\"" ]]
    then
        message_content=0
    fi
    if [ $message_content -eq 0 ]
    then
        save_content_message_into_file $log_id $device "$event" $NO_MESSAGE_ARGS_FILE
    fi
}

reset_failure_state()
{
   [ $DRY_RUN -eq 1 -o $gl_is_single_injection -eq 0 ] && return

   ## do not do anything if it is not single device mode
   [ $gl_single_injection_state -eq 1 ] && wait_single_injection_to_restore_environment

   endBusctlMarkDown
   gl_current_bustcl_title=$gl_bustl_cmd_unset_failure_title

   CMD="/bin/rm -f $MCTP_WRAPPER_FILE_PARAM"
   printBusctl $CMD
   eval $CMD
   if [ "$AML_INJECTOR_CURRENT_INJECTION" = "DeviceCoreAPI" ]
   then
      clear_Core_API_property
   fi

   restore_deviceCore_API_defaults
   endBusctlMarkDown

   local saved_log_id=$gl_log_id
   gl_log_id=0
   if [ $saved_log_id -ne 0 ]; then
      gl_current_curl_output_title="Redfish output"
      print
      ## do not print curl output there
      CUR_PRINTING_ENABLE=0
      execute_curl_commmand -H 'Content-Type: application/json' -X GET -k --user root:0penBmc ${REDFISH_ENTRIES_URI}/$saved_log_id
      curl_ok=$?
      print_and_check_asserted_device_content $saved_log_id
      if [ $curl_ok -eq 0 ]
      then
            gl_current_curl_output_title="HealthRollup output"
            execute_curl_commmand  $REDFISH_CHASSIS_URI/$device
            if [ $? -ne 0 ]
            then
               execute_curl_commmand  $REDFISH_CHASSIS_URI/HGX_${device}
            fi
      fi
      local entry_additional_data_file="`printf %03d $saved_log_id`_additional_data"
      if [ $gl_cmd_print_additional_data -eq 1 -a -s "$DIR_SAVE_ENTRIES/$entry_additional_data_file" ]
      then
          debug
          print
          cat $DIR_SAVE_ENTRIES/$entry_additional_data_file
      fi
      debug
      print
   fi
}

check_already_inserted() # return 0 -> no log id found, return > 0 got log entry id
{
   local logid=""
   local loop=1
   local back_until_entry=$gl_previous_logging_entries
   local prev_current_logging_entries=0
   while [ "$logid" = "" -a $loop -lt $ALREADY_INSERTED_ATTEMPTS ]
   do
         gl_current_logging_entries=$(latest_looging_entry)
         prev_current_logging_entries=$gl_current_logging_entries
         while [ "$logid" = "" -a $gl_current_logging_entries -gt $back_until_entry ]
         do
               debug -ne "[debug: $gl_counter_commands/$gl_total_comands] already inserted: $*, attempt[$loop/$ALREADY_INSERTED_ATTEMPTS sleep=$ALREADY_INSERTED_SLEEP], looking back at entry $gl_current_logging_entries ...\r"
               logid=$(matchDeviceAndEvent $gl_current_logging_entries $1)
               if [ "$logid" != "" ]
               then
                  ## Allows same event name happened more than once on event_info.json
                  ## shows different entry id, but does not know the right sequence
                  entry_file_name=`printf %03d $logid`
                  if [ ! -f "$DIR_SAVE_ENTRIES_ALREADY_FOUND/$entry_file_name" ]
                  then
                     touch "$DIR_SAVE_ENTRIES_ALREADY_FOUND/$entry_file_name"
                  else
                     logid=""  # keep serching
                  fi
               fi
               gl_current_logging_entries=$[ $gl_current_logging_entries - 1]
         done
         if [ $gl_current_logging_entries -eq $back_until_entry ] ## it is necessary to update the attempt counter
         then
            debug -ne "[debug: $gl_counter_commands/$gl_total_comands] already inserted: $*, attempt[$loop/$ALREADY_INSERTED_ATTEMPTS sleep=$ALREADY_INSERTED_SLEEP], looking back at entry $gl_current_logging_entries ...\r"
         fi
         loop=$[ $loop +1]
         if [ "$logid" = "" -a $loop -lt $ALREADY_INSERTED_ATTEMPTS ]
         then
            sleep $ALREADY_INSERTED_SLEEP
            back_until_entry=$prev_current_logging_entries
         fi
   done
   [ "$logid" = "" ] && return 0
   return $logid
}

set_right_cmd_line_device_index()
{
   ## restore orignal value
   gl_cmd_line_device_index=$gl_original_cmd_line_device_index
   if [ "$gl_original_cmd_line_device_index" != "" -a "$DEVICE_RANGE" != "" ]; then
         local required_double_range=0
         ## for double range "[1-3]/[2-5]" the gl_cmd_line_device_index must be in the form "firstIndex,secondIndex" like -i 1,5
         [[ "$DEVICE_RANGE" =~ "/" ]] && required_double_range=1
         local existent_double_range=0
         [[ "$gl_cmd_line_device_index"  =~ "," ]] && existent_double_range=1
         if [ $required_double_range -eq 1 -a $existent_double_range -eq 0 ]; then
            # example getting begin from second ranage = 2
            # echo "[1-3]/[2-5]" | awk -F / '{print $2}' | awk -F  '-' '{print $1}' | tr -d '\['
            local begin_second_range=$(echo $DEVICE_RANGE | awk -F / '{print $2}' | awk -F  '-' '{print $1}' | tr -d '\[')
            gl_cmd_line_device_index="${gl_cmd_line_device_index},${begin_second_range}"
         fi
   fi
}

should_skip_event() # return 1 = skip, return 0 = continue
{
   if [ $gl_cmd_line_list_events -eq 1 ]; then
        echo "${DEVICE}${DEVICE_RANGE} \"$EVENT\""
        return 1
   fi

   [ "$gl_cmd_line_device" != "" -a "$gl_cmd_line_device" != "$DEVICE" ]  && return 1
   [ "$gl_cmd_line_event" != ""  -a "$gl_cmd_line_event" != "$EVENT" ]    && return 1

   set_right_cmd_line_device_index
   if [ "$gl_cmd_line_device_index" != "" -a "$DEVICE_RANGE" != "" ]; then
         [ "$gl_cmd_line_device_index" != "$DEVICE_INDEX" ]  && return 1
   fi

   [ "$gl_cmd_line_property" != "" -a "$3" != "$gl_cmd_line_property" ] && return 1

   if [ $gl_cmd_line_unique_event -eq 1 ]
   then
      event_key="$DEVICE $EVENT"
      existsMapKey $event_key
      [ $? -eq 1 ] && return 1 ## device/event already performed, ignore other range expansions
      insertMapKey $event_key
   fi

   return 0
}

property_change() #1=object_path $2=interface, $3=property_name
{
    should_skip_event $*
    [ $? -eq 1 ] && return 0

    gl_rc=0
    gl_single_injection_state=0
    local already_inserted=0
    existsMapKey $* $METHOD $METHOD_VALUE  ## verify if path/interface/property was already inserted
    if [ $? -ne 0 ]
    then
         already_inserted=1
    fi

    gl_counter_commands=$[ $gl_counter_commands + 1 ]
    if [ $already_inserted -eq 0  -o $gl_is_single_injection -eq 0 ]
    then
         createMarkDownForEvent $DEVICE "$EVENT"
         debug
         if [ $gl_total_comands -ne 0 ]; then
            debug -n "Injecting [$gl_counter_commands/$gl_total_comands]"
            debug " DEVICE='$DEVICE' EVENT='$EVENT' ACCESSOR_TYPE='$ACCESSOR_TYPE'"
         else
            debug ============
         fi
    fi

    if [ $already_inserted -eq 1 ]; then
       check_already_inserted $*
       local logid=$?
       debug -ne "${big_space} ${big_space} ${big_space}\r"
       if [ "$logid" -ne 0 ]; then
         gl_rc=0
         debug -ne "${big_space} ${big_space} ${big_space}\r"
         gl_log_id=$logid
         gl_single_injection_state=1
         print "Created entry id $gl_log_id on phosphor logging"
         showStatus "created EventLogId [ $logid ]"
       else
         gl_rc=1
         showStatus 'Event NOT created'
       fi
       ### Reset Failure state
       reset_failure_state
       return
    fi # already inserted

    AML_INJECTOR_CURRENT_DEVICE_INDEX=""
    AML_INJECTOR_CURRENT_INJECTION="$INJECTION"        # external commands will use it
    AML_INJECTOR_CURRENT_INJECTION_PARAM="$INJECTION_PARAM"  # external commands will use it
    if [ $gl_is_single_injection -eq 1 ]
    then
      AML_INJECTOR_CURRENT_DEVICE_INDEX="$gl_cmd_line_device_index"
      echo -n "$AML_INJECTOR_CURRENT_DEVICE_INDEX $DEVICE $AML_INJECTOR_CURRENT_INJECTION_PARAM"  > $MCTP_WRAPPER_FILE_PARAM
    else
      AML_INJECTOR_CURRENT_DEVICE_INDEX="$DEVICE_INDEX"  # external commands will use it
    fi
    set_global_device_core_API_index $AML_INJECTOR_CURRENT_DEVICE_INDEX

    insertMapKey $* $METHOD $METHOD_VALUE  ## save that injection
    gl_current_logging_entries=0
    if [ "$METHOD" = "skip" ]; then
       debug "[skipping '$METHOD_VALUE'] $@"
       debug
       return
    fi


    ## necessary to restore because AML now clears calling DeviceClearData
    restore_deviceCore_API_defaults

    ### Set Failure state to make Event generation
    set_failure_state

    property_get "$@"  \
        &&  gl_current_logging_entries=$(latest_looging_entry) \
        &&  property_set_method "$@"  \
        &&  property_get "$@"

    [ $DRY_RUN -eq 1 ] && return
    if [ $gl_rc -eq 0 ]; then
       [ $gl_injection_only -eq 0 ] && verifyInjection $1
    else
       showStatus 'busctl command failed'
    fi

    ### Reset Failure state
    reset_failure_state
}

start_test()
{
   /bin/rm -f $MCTP_WRAPPER_FILE_PARAM $FAILURES_FILE
   /bin/rm -f $NO_MESSAGE_ARGS_FILE $INVALID_VALUE_MESSAGE_ARGS_FILE $INVALID_VALUE_TELEMETRIES_FILE
   /bin/rm -rf $DIR_SAVE_ENTRIES; /bin/mkdir $DIR_SAVE_ENTRIES
   /bin/mkdir $DIR_SAVE_ENTRIES_ALREADY_FOUND
   /bin/rm -f $INJECTIONS_REPORT
}

finish_test()
{
   /bin/rm -f $MAPFILE $gl_error_file $MCTP_WRAPPER_FILE_PARAM $CURRENT_INJECTED_SERVICE_FILE
   /bin/rm -rf $DIR_SAVE_ENTRIES
   gl_rc=0
   debug
   if [ $gl_cmd_line_debug -eq 1 ]; then
       debug "Finished at `date +'%Y-%m-%dT%T'`" | tee -a $INJECTIONS_REPORT
       debug | tee -a $INJECTIONS_REPORT
       debug "Failed Injections: $gl_failures"  | tee -a $INJECTIONS_REPORT
       if [ -s "$FAILURES_FILE" ]
       then
         cat $FAILURES_FILE   | tee -a $INJECTIONS_REPORT
         gl_rc=$[$gl_rc + 1]
       fi
       if [ -s "$NO_MESSAGE_ARGS_FILE" ]
       then
         debug | tee -a $INJECTIONS_REPORT
         debug "Events without MessageArgs:" | tee -a $INJECTIONS_REPORT
         cat $NO_MESSAGE_ARGS_FILE | tee -a $INJECTIONS_REPORT
         gl_rc=$[$gl_rc + 1]
       fi
       if [ -s "$INVALID_VALUE_MESSAGE_ARGS_FILE" ]
       then
         debug | tee -a $INJECTIONS_REPORT
         debug "Events with invalid values in MessageArgs '$ERROR_VALUE_CONTENT':" \
              | tee -a $INJECTIONS_REPORT
         cat $INVALID_VALUE_MESSAGE_ARGS_FILE | tee -a $INJECTIONS_REPORT
         gl_rc=$[$gl_rc + 1]
       fi
       if [ -s "$INVALID_VALUE_TELEMETRIES_FILE" ]
       then
         debug | tee -a $INJECTIONS_REPORT
         debug "Events with invalid values in Telemetries '$ERROR_VALUE_CONTENT':" \
                | tee -a $INJECTIONS_REPORT
         cat $INVALID_VALUE_TELEMETRIES_FILE | tee -a $INJECTIONS_REPORT
         gl_rc=$[$gl_rc + 1]
       fi
       debug | tee -a $INJECTIONS_REPORT
       debug "Successful Injections: $gl_injections" | tee -a $INJECTIONS_REPORT
       debug | tee -a $INJECTIONS_REPORT
       debug "Return code: $gl_rc"  | tee -a $INJECTIONS_REPORT
   fi
   /bin/rm -f $FAILURES_FILE
   /bin/rm -f $NO_MESSAGE_ARGS_FIL $INVALID_VALUE_MESSAGE_ARGS_FILE $INVALID_VALUE_TELEMETRIES_FILE
}

exit_test()
{
   if [ "$gl_cmd_line_device" != "" ]
   then
      restore_deviceCore_API_defaults
   fi
   finish_test
   exit $gl_rc
}

trap exit_test 1 2 3 4 5 6 7 15

if [ $gl_cmd_line_keep_existing_logs -eq 0 ]; then
   [ $gl_is_single_injection -eq 0 ] &&  \
       echo  "busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll"
   busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll
fi

start_test  ## starts configuration here


gl_previous_logging_entries=$(latest_looging_entry)
if [ "$gl_previous_logging_entries" = "" ]; then # empty first time
       gl_previous_logging_entries=0
fi
debug | tee -a $INJECTIONS_REPORT
debug "Started at `date +'%Y-%m-%dT%T'`" | tee -a $INJECTIONS_REPORT
debug existent log entries = $gl_previous_logging_entries



