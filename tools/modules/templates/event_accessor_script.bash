#!/bin/bash
# This script is generated by event_validation.py, be aware that changes will be lost!

SERVICE_GPUMGR=xyz.openbmc_project.GpuMgr
SERVICE_GPIO_HANDLER=xyz.openbmc_project.GpioStatusHandler
SERVICE_GPU_OOB_RECOVERY=xyz.openbmc_project.GpuOobRecovery
DBUS_CALL_ARGS="$SERVICE_GPUMGR /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server"
DBUS_CALL_GET_ARGS="$DBUS_CALL_ARGS DeviceGetData isi"
DBUS_CALL_SET_ARGS="$DBUS_CALL_ARGS DeviceSetData isu"
DBUS_CALL_CLEAR_ARGS="$DBUS_CALL_ARGS  DeviceClearData is"
DBUS_CALL_CLEAR_PASS_THROUGH_FPGA="$DBUS_CALL_ARGS clearPassthroughFpga"
DBUS_CALL_SET_PASS_THROUGH_FPGA="$DBUS_CALL_ARGS setPassthroughFpga is"
DBUS_CALL_SET_GPU_XID_EVENT_STRING="$DBUS_CALL_ARGS setGpuXidEventString s"
DBUS_OBJECT_MAPPER_GET_OBJECT="xyz.openbmc_project.ObjectMapper /xyz/openbmc_project/object_mapper xyz.openbmc_project.ObjectMapper GetObject sas"

CURRENT_INJECTED_SERVICE_FILE=/tmp/.current_injected_service

# used to clear line message
big_space="                                                                                             "

## global variables
gl_property_value=""
gl_property_type=""
gl_new_property_value=""
gl_old_property_value=""
gl_rc=0
gl_script_rc=0
gl_total_comands=0  # will be set as the total intended commands
gl_counter_commands=0 # counter for commands being executed
gl_injections=0  # successful injections
gl_current_logging_entries=0
gl_previous_logging_entries=""
gl_injection_only=0
gl_failures=0
gl_error_file=/tmp/.event_error_$$
gl_cmd_line_device=""
gl_cmd_line_event=""
gl_cmd_line_device_index=""
gl_cmd_line_keep_existing_logs=0
gl_cmd_line_list_events=0
gl_cmd_line_property=""
gl_cmd_line_debug=0
gl_is_single_injection=0 # 1 means is single injection
gl_single_injection_state=0  ## 0 not inserted, 1 = insert
gl_cmd_line_markdown=0
gl_markdown_file=""
AML_INJECTOR_CURRENT_DEVICE_INDEX=""
MAPFILE=/tmp/.mapfile_$$
TIMESTAMP_INJECTION_STARTED=0            ## control time between insert failure and restore
WAIT_TIME_FOR_RELASE_INJECTION_DATA=90
FAILURES_FILE=/tmp/.not_injected_$$
MCTP_WRAPPER_FILE_PARAM=/tmp/.mctp_param
gl_busctl_cmd_counter=0
gl_bustl_cmd_set_failure_title="Failure preparation commands"
gl_bustl_cmd_unset_failure_title="Failure clearing commands"
gl_current_bustcl_title=$gl_bustl_cmd_set_failure_title
gl_current_curl_output_title=""

DIR_SAVE_ENTRIES="/tmp/injected"
REDFISH_ENTRIES_URI="http://127.0.0.1:80/redfish/v1/Systems/HGX_Baseboard_0/LogServices/EventLog/Entries"
REDFISH_CHASSIS_URI="http://127.0.0.1:80/redfish/v1/Chassis"

CURL_CMD="/tmp/oobaml/bin/curl -i"
gl_log_id=0  ## entry to be generated for the firt busctl command
DRY_RUN=0


help()
{
   echo
   echo " -l|--list-events           just list current 'device event' list"
   echo " -D|--debug                 adds few debug messages"
   echo " -k|--keep-existent-logs    do not remove phosphor log entries at beginning"
   echo " -d|--device <device>       a device defined in event_info.json such as GPU, HMC, etc"
   echo " -e|--event <event-name>    the event as defined in event_info.json (use double quotes)"
   echo " -i|--device-index <index>  plus --device and --event it sets the 'single injection' use index zero when there is no range in the 'device'"
   echo " -p|--property <prop-name>  performs injections on all events that has that DBUS property, e.g., I2C3_ALERT"
   echo " -m|--markdown              only for 'single injection' generates markdown output suitable to create documents, inside '/tmp/md' directory"
   echo " -h|--help                  shows the help"
   echo
}

while [ "$1" != "" ]; do
    case "$1"  in
        -r|--run)    DRY_RUN=0;;  # run, default DRY_RUN
        -n|--inject-only)         # do not log for logs in phosphor logging
                     DRY_RUN=0
                     gl_injection_only=1;;
        -d|--device) shift; gl_cmd_line_device="$1";;
        -e|--event) shift; gl_cmd_line_event="$1";;
        -k|--keep-existent-logs) gl_cmd_line_keep_existing_logs=1;;
        -l|--list-events) gl_cmd_line_list_events=1;;
        -i|--device-index) shift; gl_cmd_line_device_index="$1";;
        -p|--property) shift; gl_cmd_line_property="$1";;
        -D|--debug) gl_cmd_line_debug=1;;
        -m|--markdown) gl_cmd_line_markdown=1;;
        -h|--help) help; exit 0;;
    esac
    shift
done

if [ $DRY_RUN -eq 1 ]; then
   debug; debug running in DRY-RUN mode...; debug ... ; sleep 2
fi

## when specified only --device and --event the user can pass -D to enable debug
if [ $gl_cmd_line_debug -eq 0 -a "$gl_cmd_line_device_index" = "" ]; then
    gl_cmd_line_debug=1
fi

if [ "$gl_cmd_line_device_index" != "" -a "$gl_cmd_line_event" != "" ]
    then
       gl_is_single_injection=1
fi

debug()
{
   [ $gl_cmd_line_debug -eq 0 ] && return
   echo "$@"
}

print()
{
   [ $gl_cmd_line_debug -eq 1 ] && return
   echo "$@"
}


endBusctlMarkDown()
{
  if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
  then
     echo  "|"  >> "$gl_markdown_file"
     gl_busctl_cmd_counter=0
  fi
}

## always print bustcl commands on the screen
## if --markdown is active, also prints saves in the markdown file
printBusctl()
{
   echo "$@"
   if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
   then
      if [ $gl_busctl_cmd_counter -eq 0 ] ## create table
      then
         echo >> "$gl_markdown_file"
         echo    "|$gl_current_bustcl_title|"    >> "$gl_markdown_file"
         echo    "|:-----------------------|"    >> "$gl_markdown_file"
         echo -n "|$@"                           >> "$gl_markdown_file"
      else
         echo -n "<br>$@"                        >> "$gl_markdown_file"
      fi
      gl_busctl_cmd_counter=$[ $gl_busctl_cmd_counter + 1 ]
   fi
}

createMarkDownForEvent()
{
   device=$1
   event="$2"
   print "$device \"$event\""
   if [ $gl_cmd_line_markdown -eq 1 -a $gl_is_single_injection -eq 1 ]
   then
      mkdir -p /tmp/md 2> /dev/null
      gl_markdown_file="/tmp/md/${device}_\"${event}\".md"
      echo "## $device \"$event\"" > "$gl_markdown_file"
      echo                        >> "$gl_markdown_file"
      echo "|Command line|"       >> "$gl_markdown_file"
      echo "|:--------|"          >> "$gl_markdown_file"
      echo "|./test_AML.sh inject --device $device --event \"$event\" --device-index $gl_cmd_line_device_index|"  >> "$gl_markdown_file"
   fi
}

createMarkDownForFileContent() # $1=file
{
    echo >> "$gl_markdown_file"
    echo    "|$gl_current_curl_output_title|" >> "$gl_markdown_file"
    echo    "|:-----------------------|"      >> "$gl_markdown_file"
    first_line=0
    save_ifs=$IFS
    IFS=''
    while  read -r line; do
      out=`echo $line | tr -d '\n' | tr -d '\r' | sed -e 's/ /\&nbsp;/g'`
      if [ "$out" != "" ]
      then
         if [ $first_line -eq 0 ]
         then
            first_line=1
            echo -n "|$out"     >> "$gl_markdown_file"
         else
            echo -n "<br>$out"  >> "$gl_markdown_file"
         fi
      fi
    done < $1
    IFS=$save_ifs
    echo "|" >> "$gl_markdown_file"
}

createMapKey()
{
   key=""
   for k in $*
   do
       key="${key}::${k}"
   done
   echo $key
}

existsMapKey() # 0 does not exist
{
    local key=`createMapKey $*`
    exists=`egrep "^${key}" $MAPFILE 2> /dev/null`
    if [ $? -eq 0 ]  ## exists
    then
         return 1
    fi
    return 0
}

insertMapKey()
{
  local key=`createMapKey $*`
  existsMapKey $*
  if [ $? -eq 0 ]
  then
      echo $key >> $MAPFILE
  fi
}

getService() # $1 = object path $2 = interface
{
   local obj=$1
   local intf=$2
   service=`busctl call $DBUS_OBJECT_MAPPER_GET_OBJECT ${obj} 1 ${intf} | awk '{print $3}' | tr -d '"'`
   if [ "$service" = "" ]; then
      if [ "$1" = "/xyz/openbmc_project/GpioStatusHandler" ]; then
         service=$SERVICE_GPIO_HANDLER
      elif [ "$1" = "/xyz/openbmc_project/GpuOobRecovery" ]; then
      service=$SERVICE_GPU_OOB_RECOVERY
      else
         service=$SERVICE_GPUMGR
      fi
   fi
   echo -n $service > $CURRENT_INJECTED_SERVICE_FILE
   echo $service
}


change_digit()
{
   local digit=$1
   if [ "$digit" = "9" ]; then
      digit=8
   else
      digit=$[ $digit + 1 ]
   fi
   echo $digit
}

change_string()
{
   local value="$gl_property_value"
   [ "$METHOD" = "not_equal" ] && value="${METHOD_VALUE}"
   ## 1 change last digit if that exists, example "PCIeTypes.Gen5" becomes "PCIeTypes.Gen6"
   local last_character="${value: -1}"
   if [[ $last_character =~ [0-9] ]]; then
      digit=`change_digit $last_character`
      ret=${value%?}$digit
      if [ "$ret" = "$gl_property_value" ]
      then
         digit=`change_digit $digit`
         ret=${value%?}$digit
      fi
   fi
   if [ "$ret" = "" ]; then
     ret=`date +%s`
   fi
   echo $ret
}

calculate_number()
{
  result=$1
  rest=$[ $result % 2]
  if [ $rest -eq 0 ]; then
     result=$[ $result * 2 ]
  else
     result=$[ $result + 1]
  fi
  echo $result
}


change_number() # $1 = value to change
{
  local result=${gl_property_value};
  if [ "$METHOD" = "equal" -o  "$METHOD" = "not_equal" ]; then
      result=${METHOD_VALUE}
  fi
  if [ "$result" = "0" ]; then
      result=1
  fi
  result=`calculate_number $result`
  if [ "$result" = "${gl_property_value}" ]; then
      result=`calculate_number $result`
  fi
  echo $result
}

latest_looging_entry()
{
    [ $gl_injection_only -eq 1 ] && return 0
    latest_entry=0
    for entry_value in  $(busctl tree xyz.openbmc_project.Logging | grep /xyz/openbmc_project/logging/entry/ | awk -F / '{ print $NF}' 2> $gl_error_file)
    do
       entry=${entry_value//[!0-9]/}
       [ "$entry" != "" -a $entry -gt $latest_entry ] && latest_entry=$entry
    done
    echo $latest_entry
}

property_get() #1=object_path $2=interface, $3=property_name
{
    gl_property_value=""
    gl_property_type=""
    local cmd="busctl get-property `getService $1 $2`  $@"
    printBusctl $cmd
    local get_value=$(eval $cmd 2> $gl_error_file)
    if [ $? -ne 0 -o "$get_value" = "" ]; then
        gl_rc=1
    else
        debug " $get_value"
        gl_property_value=$(echo $get_value | awk '{print $NF}' | tr -d '\"' 2> $gl_error_file )
        gl_property_type=$(echo $get_value | awk '{print $1}' 2> $gl_error_file)
        [ "$gl_property_value" = "" -o "$gl_property_type" = "" ] && gl_rc=1
    fi
    return $gl_rc
}


change_value_method() #1=value to change
{
    case "$METHOD" in
       "bitmask") gl_new_property_value=$[ ( ${gl_property_value} + 1 ) | ${METHOD_VALUE} ];;
       "lookup")  gl_new_property_value=${METHOD_VALUE};;
       *)         gl_new_property_value=`change_number`;;
    esac
}


property_set_method() #1=object_path $2=interface, $3=property_name
{
    gl_new_property_value=""
    gl_old_property_value=$gl_property_value
    if [ "$METHOD" = "bitmask" ]
    then
         export METHOD="force"
         if [ "$gl_property_value" != "0" ]; then
            local save_method_value=${METHOD_VALUE}
            METHOD_VALUE="0" property_set "$@"
            METHOD_VALUE=$save_method_value
         fi
         ## leave method as force to put the right value
    elif [ "$METHOD" = "lookup" ]
    then
        local save_method_value=${METHOD_VALUE}
        METHOD="add" METHOD_VALUE="1" property_set "$@"
        gl_rc=$?
        gl_property_value=$gl_new_property_value
        METHOD="lookup"
        METHOD_VALUE="$save_method_value"
    fi

    # Main call to property_set
    property_set "$@"

    # extra call to property_set if necessary
    if [ $gl_rc -eq 0 ]; then
       if [ "$METHOD" = "equal" -a "$gl_new_property_value" != "${METHOD_VALUE}" ]
       then
            gl_old_property_value="" # force set
            gl_new_property_value=${METHOD_VALUE}
            METHOD="force" property_set "$@"
       fi
       if [ "$METHOD" = "not_equal" -a "$gl_new_property_value" = "${METHOD_VALUE}" ]
       then
            ## force it as string to set back the old value
            METHOD="force"  METHOD_VALUE="$gl_old_property_value"  property_set "$@"
       fi
    fi
    return $gl_rc
}


property_set() #1=object_path $2=interface, $3=property_name
{

    if [ "$METHOD" = "force" ]; then ## force is internal only
        gl_new_property_value=${METHOD_VALUE}
    else
       if [ "$gl_old_property_value" != "" ]; then # allow bypassing this logic
          case $gl_property_type in
               b)   echo $gl_old_property_value | grep -i true > /dev/null
                   if [ $? -eq 0 ]; then
                       gl_new_property_value="false"
                   else
                       gl_new_property_value="true"
                  fi
                  ;;
               s|as)   gl_new_property_value=`change_string`
                    [ "$METHOD" = "equal" ] && gl_new_property_value=${METHOD_VALUE}
                  sleep 1
                  ;;
              ## that should work for integers and double types
               *)   change_value_method;
          esac
       fi
    fi

    ocurr=""
    [ "${gl_property_type:0:1}" = "a" ] && ocurr="1"

    cmd="busctl set-property `getService $1 $2`  $@ $gl_property_type $ocurr '$gl_new_property_value'"
    printBusctl $cmd
    [ $DRY_RUN -eq 1 ] && return
    eval $cmd 2> $gl_error_file
    gl_rc=$?
    if [ $gl_rc -eq 0 -a  $gl_injection_only -eq 1 ]; then
       gl_injections=$[ $gl_injections + 1 ]
    fi
    return $gl_rc
}


getAssertedDevice() #1=entry
{
   entry_file_name=`printf %03d $1`
   if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
      cat $DIR_SAVE_ENTRIES/$entry_file_name | tail -1
   fi
}


matchDeviceAndEvent() # $1=entryid to check, #2 optional the object path
{
    device=""
    event=""
    entry_file_name=`printf %03d $1`
    if [ -s "$DIR_SAVE_ENTRIES/$entry_file_name" ]; then
        event=`cat $DIR_SAVE_ENTRIES/$entry_file_name | head -n 1`
    else
       device=$(busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$1 xyz.openbmc_project.Logging.Entry AdditionalData 2>/dev/null \
              | awk -F 'namespace='  '{print $2}' | tr -d \")
        if [ "$device" != "" ]; then
            event=$(busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$1 xyz.openbmc_project.Logging.Entry Message 2>/dev/null | cut -f2-90 -d' ' | tr -d \")
            echo "$event"   > $DIR_SAVE_ENTRIES/$entry_file_name
            echo "$device" >> $DIR_SAVE_ENTRIES/$entry_file_name
        else
            touch $DIR_SAVE_ENTRIES/$entry_file_name
            return
        fi
    fi

    if [ "$event" = "$EVENT" ]; then
       device=`getAssertedDevice $1`
       local device_to_compare=$DEVICE
       while [ "`echo $device_to_compare | grep -E '[0-9]$'`" != "" -o ${device_to_compare: -1} = "_" ]; do
           device_to_compare=${device_to_compare:0:-1}
       done
       if [ $# -eq 2 ]; then # parameter 2 passed , object path
          object=$(echo $2 | awk -F / '{print $NF}')
          if [[ "$object" == "$DEVICE"* ]]; then
              device_to_compare=$object
          fi
       fi
       if [[ "$device" == "$device_to_compare"* ]]; then
           echo $1 ## correct entry id
       else
          if [[ $device_to_compare =~ $device ]]; then
            echo $1 ## correct entry id
          fi
       fi
    fi
}

verifyInjection()
{
    local interactions=20
    local logid="" # more then one event can be created
    print "Waiting for the Injection, it may take some time ..."
    while [ "$logid" = "" -a $interactions -gt 0 ]; do
       debug -ne "waiting for the event, trying at most $interactions times to get a new EventLogId ...\r"

       sleep 4
       local new_logging_entries=$(latest_looging_entry)
       local expected_logging_entry=$[ $gl_current_logging_entries + 1 ]
       if [ $new_logging_entries -gt $gl_current_logging_entries ]; then
          while [ "$logid" = "" -a $expected_logging_entry -le $new_logging_entries ]; do
               logid=$(matchDeviceAndEvent $expected_logging_entry $1)
               expected_logging_entry=$[$expected_logging_entry + 1]
          done
       fi
       interactions=$[ $interactions - 1 ]
    done
    if [ "$logid" != "" ]; then
       debug -ne "${big_space} ${big_space} ${big_space} \r"
       gl_log_id=$logid
       gl_single_injection_state=1
       showStatus "created EventLogId [ $logid ]"
    else
       gl_rc=1
       showStatus 'busctl commands worked but Event NOT created'
    fi
}

showStatus()
{
    status='injected'
    if [ $gl_rc -ne 0 ]; then
        status='failed'
        debug "FAILED at `date`"
        gl_failures=$[ gl_failures + 1 ]
        print "FAILED injection for DEVICE='$DEVICE' EVENT='$EVENT'"
        debug "	[$gl_counter_commands/$gl_total_comands] DEVICE='$DEVICE' EVENT='$EVENT'" >> $FAILURES_FILE
    else
        gl_injections=$[ $gl_injections + 1 ]
    fi
    error_msg=$(cat $gl_error_file 2> /dev/null)
    message="[debug: $gl_counter_commands/$gl_total_comands] $status DEVICE='$DEVICE' EVENT='$EVENT' : '$1' '$error_msg'"
    debug $message
}

getDeviceFromAdditionalData() #$1 = entry id
{
  addData=`busctl get-property xyz.openbmc_project.Logging /xyz/openbmc_project/logging/entry/$entry xyz.openbmc_project.Logging.Entry AdditionalData 2>/dev/null | cut -f3-550 -d' '`


    device=`echo $addData | awk -F 'namespace='  '{print $2}' | tr -d \"`
}

wait_single_injection_to_restore_environment()
{
   if [ $TIMESTAMP_INJECTION_STARTED -ne 0 ]; then
         timestamp=`date +%s`
         wait_time=$[ $timestamp - $TIMESTAMP_INJECTION_STARTED ]
         TIMESTAMP_INJECTION_STARTED=0
         if [ $wait_time -lt $WAIT_TIME_FOR_RELASE_INJECTION_DATA ]; then
            debug "waiting $wait_time seconds to let process other events"
            sleep $wait_time
         fi
   fi
}

set_failure_state()
{
   [ $DRY_RUN -eq 1 -o $gl_is_single_injection -eq 0 ] && return


   if [ $gl_cmd_line_keep_existing_logs -eq 0 ]
   then
        CMD="busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll"
        printBusctl $CMD
        eval $CMD >/dev/null
   fi

   TIMESTAMP_INJECTION_STARTED=`date +%s`
   ## force return 0 to all calls to " busctl call xyz.openbmc_project.GpuMgr /xyz/openbmc_project/GpuMgr xyz.openbmc_project.GpuMgr.Server DeviceGetData"
   CMD="busctl call $DBUS_CALL_ARGS setDeviceDataForAll u 0"
   printBusctl $CMD
   eval $CMD >/dev/null
   # clear return for mctp-error-detection that calls PassthroughFpga iyyyau 0 0xb1 0x81 0 0
   CMD="busctl call $DBUS_CALL_CLEAR_PASS_THROUGH_FPGA"
   printBusctl $CMD
   eval $CMD >/dev/null

   CMD="echo -n \"$AML_INJECTOR_CURRENT_DEVICE_INDEX $DEVICE $AML_INJECTOR_CURRENT_INJECTION_PARAM\"  > $MCTP_WRAPPER_FILE_PARAM"
   printBusctl $CMD
   eval $CMD

   if [ "$AML_INJECTOR_CURRENT_INJECTION" = "CMDLINE" ]
   then
      read -r command args < <(echo $INJECTION_PARAM)
      if [ "$command" = "mctp-error-detection" ]
      then
         CMD="busctl call $DBUS_CALL_SET_PASS_THROUGH_FPGA $AML_INJECTOR_CURRENT_DEVICE_INDEX $DEVICE"
         printBusctl  $CMD
         eval $CMD
      fi
   elif [ "$AML_INJECTOR_CURRENT_INJECTION" = "DeviceCoreAPI" ]
   then
      [ "$INJECTION_CHECK_VALUE" = "" ] && INJECTION_CHECK_VALUE=1
      [ "$INJECTION_CHECK" = "not_equal" ] && INJECTION_CHECK_VALUE=$[ $INJECTION_CHECK_VALUE + 1]
      if [ "$INJECTION_CHECK" != "" -a $INJECTION_PARAM = "gpu.xid.event" ]
      then
            CMD="busctl call $DBUS_CALL_SET_GPU_XID_EVENT_STRING \"$INJECTION_CHECK_VALUE\""
            printBusctl $CMD
            eval $CMD > /dev/null
      fi
      CMD="busctl call $DBUS_CALL_SET_ARGS $AML_INJECTOR_CURRENT_DEVICE_INDEX $INJECTION_PARAM $INJECTION_CHECK_VALUE"
      printBusctl $CMD
      eval $CMD > /dev/null
      if [ $gl_cmd_line_debug -eq 1 ]
      then
         CMD="busctl call  $DBUS_CALL_GET_ARGS $AML_INJECTOR_CURRENT_DEVICE_INDEX $INJECTION_PARAM 1"
         printBusctl $CMD
         eval $CMD
      fi
   fi ## it is CMDLINE

}

execute_curl_commmand()
{
  CMD="$CURL_CMD $@"
  debug $CMD
  CUR_OUTPUT=/tmp/.curl_outpupt
  CUR_STATUS=/tmp/.curl_status
  eval $CMD 1>$CUR_STATUS 2>/dev/null
  ok=`grep '200 OK' $CUR_STATUS | grep HTTP`
  ret=1
  if [ "$ok" != "" ]
  then
     ret=0
     grep -v "^[A-Z]"  $CUR_STATUS > $CUR_OUTPUT
     cat $CUR_OUTPUT
     if [ $gl_cmd_line_markdown -eq 1 ]
     then
         createMarkDownForFileContent $CUR_OUTPUT
     fi
  fi
  /bin/rm -f $CUR_OUTPUT $CUR_STATUS
  return $ret
}

reset_failure_state()
{
   [ $DRY_RUN -eq 1 -o $gl_is_single_injection -eq 0 ] && return

   ## do not do anything if it is not single device mode
   [ $gl_single_injection_state -eq 1 ] && wait_single_injection_to_restore_environment

   endBusctlMarkDown
   gl_current_bustcl_title=$gl_bustl_cmd_unset_failure_title

   CMD="/bin/rm -f $MCTP_WRAPPER_FILE_PARAM"
   printBusctl $CMD
   eval $CMD
   if [ "$AML_INJECTOR_CURRENT_INJECTION" = "DeviceCoreAPI" ]
   then
      CMD="busctl call $DBUS_CALL_CLEAR_ARGS $AML_INJECTOR_CURRENT_DEVICE_INDEX $INJECTION_PARAM"
      printBusctl $CMD
      eval $CMD > /dev/null
   fi

   ## also restore  mctp-error-detection
   CMD="busctl call $DBUS_CALL_ARGS clearDeviceDataForAll" >/dev/null
   printBusctl $CMD
   eval $CMD
   endBusctlMarkDown

   local saved_log_id=$gl_log_id
   gl_log_id=0
   if [ $saved_log_id -ne 0 ]; then
      device=`getAssertedDevice $saved_log_id`
      print
      print "Entry id = $saved_log_id asserted device = '$device' "
      gl_current_curl_output_title="Redfish output"
      execute_curl_commmand -H 'Content-Type: application/json' -X GET -k --user root:0penBmc ${REDFISH_ENTRIES_URI}/$saved_log_id
      if [ $? -eq 0 ]
      then
            gl_current_curl_output_title="HealthRollup output"
            execute_curl_commmand  $REDFISH_CHASSIS_URI/$device
            if [ $? -ne 0 ]
            then
               execute_curl_commmand  $REDFISH_CHASSIS_URI/HGX_${device}
            fi
      fi
      debug
      print
   fi
}

property_change() #1=object_path $2=interface, $3=property_name
{
    gl_rc=0
    gl_single_injection_state=0
    if [ $gl_cmd_line_list_events -eq 1 ]; then
        echo "${DEVICE}${DEVICE_RANGE} \"$EVENT\""
        return 0
    fi
    go_out=0
    [ "$gl_cmd_line_device" != "" -a "$gl_cmd_line_device" != "$DEVICE" ]  && go_out=1
    [ "$gl_cmd_line_event" != ""  -a "$gl_cmd_line_event" != "$EVENT" ]    && go_out=1
    if [ "$gl_cmd_line_device_index" != "" -a "$DEVICE_RANGE" != "" ]; then
      [ "$gl_cmd_line_device_index" != "$DEVICE_INDEX" ]  && go_out=1
    fi

    [ "$gl_cmd_line_property" != "" -a "$3" != "$gl_cmd_line_property" ] &&  go_out=1

    [ $go_out -eq 1 ] && return 0

    AML_INJECTOR_CURRENT_DEVICE_INDEX=""
    AML_INJECTOR_CURRENT_INJECTION="$INJECTION"        # external commands will use it
    AML_INJECTOR_CURRENT_INJECTION_PARAM="$INJECTION_PARAM"  # external commands will use it
    if [ $gl_is_single_injection -eq 1 ]
    then
       AML_INJECTOR_CURRENT_DEVICE_INDEX="$gl_cmd_line_device_index"
       echo -n "$AML_INJECTOR_CURRENT_DEVICE_INDEX $DEVICE $AML_INJECTOR_CURRENT_INJECTION_PARAM"  > $MCTP_WRAPPER_FILE_PARAM
    else
       AML_INJECTOR_CURRENT_DEVICE_INDEX="$DEVICE_INDEX"  # external commands will use it
    fi

    createMarkDownForEvent $DEVICE "$EVENT"
### Set Failure state to make Event generation
    set_failure_state
    gl_counter_commands=$[ $gl_counter_commands + 1 ]
    debug
    if [ $gl_total_comands -ne 0 ]; then
       debug -n "Injecting [$gl_counter_commands/$gl_total_comands]"
       debug " DEVICE='$DEVICE' EVENT='$EVENT' ACCESSOR_TYPE='$ACCESSOR_TYPE'"
    else
       debug ============
    fi

    existsMapKey $* $METHOD $METHOD_VALUE  ## verify if path/interface/property was already inserted
    if [ $? -ne 0 ]; then # already inserted
       gl_current_logging_entries=$(latest_looging_entry)
       local logid=""
       while [ "$logid" = "" -a $gl_current_logging_entries -gt $gl_previous_logging_entries ]
       do
          debug -ne "[debug: $gl_counter_commands/$gl_total_comands] already inserted: $*, looking back at entry $gl_current_logging_entries ...\r"
          logid=$(matchDeviceAndEvent $gl_current_logging_entries $1)
          gl_current_logging_entries=$[ $gl_current_logging_entries - 1]
       done
       debug -ne "${big_space} ${big_space} ${big_space}\r"
       if [ "$logid" != "" ]; then
          gl_rc=0
       debug -ne "${big_space} ${big_space} ${big_space}\r"
       gl_log_id=$logid
       gl_single_injection_state=1
       print "Created entry id $gl_log_id on phosphor logging"
       showStatus "created EventLogId [ $logid ]"
       else
           gl_rc=1
           showStatus 'Event NOT created'
       fi
### Reset Failure state
       reset_failure_state
       return
    fi
    insertMapKey $* $METHOD $METHOD_VALUE  ## save that injection
    gl_current_logging_entries=0
    if [ "$METHOD" = "skip" ]; then
       debug "[skipping '$METHOD_VALUE'] $@"
       debug
### Reset Failure state
       reset_failure_state
       return
    fi
    property_get "$@"  \
        &&  gl_current_logging_entries=$(latest_looging_entry) \
        &&  property_set_method "$@"  \
        &&  property_get "$@"

   [ $DRY_RUN -eq 1 ] && return
   if [ $gl_rc -eq 0 ]; then
       [ $gl_injection_only -eq 0 ] && verifyInjection $1
   else
       showStatus 'busctl command failed'
   fi
### Reset Failure state
   reset_failure_state
}

start_test()
{
   /bin/rm -f $MCTP_WRAPPER_FILE_PARAM

}

finish_test()
{
   /bin/rm -f $MAPFILE $gl_error_file $MCTP_WRAPPER_FILE_PARAM $CURRENT_INJECTED_SERVICE_FILE
   /bin/rm -rf $DIR_SAVE_ENTRIES

   if [ $gl_cmd_line_debug -eq 1 ]; then
       debug; debug "Failed Injections: $gl_failures"
       cat $FAILURES_FILE
       debug; debug "Successful Injections: $gl_injections"
       debug "finished at `date +"%Y-%m-%dT%T"`"
       gl_rc=$[$gl_total_comands - $gl_injections]
   fi
   /bin/rm -f $FAILURES_FILE
}

exit_test()
{
   if [ "$gl_cmd_line_device" != "" ]
   then
      CMD="busctl call $DBUS_CALL_ARGS clearDeviceDataForAll" >/dev/null
      eval $CMD
   fi
   finish_test
   /bin/rm -f $FAILURES_FILE
   exit $gl_rc
}

trap exit_test 1 2 3 4 5 6 7 15

if [ $gl_cmd_line_keep_existing_logs -eq 0 ]; then
   [ $gl_is_single_injection -eq 0 ] &&  \
       print  "busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll"
   busctl call xyz.openbmc_project.Logging /xyz/openbmc_project/logging xyz.openbmc_project.Collection.DeleteAll DeleteAll
fi

start_test  ## starts configuration here

/bin/rm -rf $DIR_SAVE_ENTRIES; /bin/mkdir $DIR_SAVE_ENTRIES
echo > $FAILURES_FILE
gl_previous_logging_entries=$(latest_looging_entry)
if [ "$gl_previous_logging_entries" = "" ]; then # empty first time
       gl_previous_logging_entries=0
fi
debug;
debug  "started at `date +"%Y-%m-%dT%T"`"
debug existent log entries = $gl_previous_logging_entries



