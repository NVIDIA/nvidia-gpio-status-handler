#!/usr/bin/env bash

# Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
#
#  NVIDIA CORPORATION and its licensors retain all intellectual property
#  and proprietary rights in and to this software, related documentation
#  and any modifications thereto.  Any use, reproduction, disclosure or
#  distribution of this software and related documentation without an express
#  license agreement from NVIDIA CORPORATION is strictly prohibited.

# Wrapper to map command + device calls onto corresponding i2c bus/addr test

set -o pipefail

APP_NAME="i2c_wrapper"
APP_VER="0.1"

# Platform dependent profile.
# Use Case 1:
# In OpenBMC recipe, replace PROFILE_FILE with 
# selftest_i2c_profile.csv proper path.
#
# Use Case 2:
# From cmdline, define PROFILE_FILE=<path of profile.csv> 
# before calling this script to run with custom profile.
[ -z "$PROFILE_FILE" ] && PROFILE_FILE="selftest_i2c_profile.csv"
profile_path="${PROFILE_FILE}"

# Maps current namespace deviceId to general device name.
# Eg. GPU_SXM_5 -> GPU0
# For details refer to target help
[ -z "$DEVICE_NAME_MAPPER" ] && DEVICE_NAME_MAPPER="device-id-norm.sh" 

show_help()
{
    echo "A wrapper for checking i2c device link status, ver=${APP_VER}."
    echo
    echo "<usage>"
    echo "  ${APP_NAME} [-verbose] [-dry-run|-test-run] <cmd> <dev_name>"
    echo "  ${APP_NAME} i2c_access GPU_SXM_1"
    echo
    echo "<options>"
    echo "  -verbose          - allows to output dbg infos."
    echo "  -dry-run          - simulates external dependency tool value read"
    echo "                      as 0xAA"
    echo "  -test-run         - used to test"
    echo "  cmd               - currently only i2c_access cmd is supported"
    echo "  dev_name          - device name to look for in platform profile file"
    echo
}

dbg()
{
    if [ $TEST_RUN -ne 1 ] && [ $VERBOSE -eq 1 ]; then
        echo "[dbg] $1"
    fi
}

## MAIN
DRY_RUN=0
TEST_RUN=0
VERBOSE=0

## -verbose
if [ "$1"  = "-verbose" ]; then
   VERBOSE=1
   dbg "verbose mode"
   shift
fi

## -dry-run just prints the i2ctransfer command line
if [ "$1"  = "-dry-run" ]; then
   DRY_RUN=1
   shift
fi

## -test-run prints single line in format ()
if [ "$1"  = "-test-run" ]; then
    TEST_RUN=1
    shift
fi

if [ $TEST_RUN -eq 1 ]; then

    if [ $# -ne 4 ]; then
        echo "Wrong args for tests, see example below."
        echo "${APP_NAME} -test-run i2c_access GPU_SXM_3 0xAA 0"
        echo "where 0xAA is artificial i2cget output and 0 artificial RC code"
        exit 1
    fi

    COMMAND="$1";shift
    DEVNAME="$1";shift
    ARTIFICIAL_OUTPUT="$1"; shift
    ARTIFICIAL_OUTPUT=${ARTIFICIAL_OUTPUT//'_'/' '}
    ARTIFICIAL_RC_CODE=$1; shift
else

    if [ $# -ne 2 ]; then
        show_help
        exit 1
    fi

    COMMAND="$1";shift
    DEVNAME="$1";shift
fi

# Validate command
if [ "$COMMAND" != "i2c_access" ]; then
    echo "Error: unsupported command, currently only i2c_access supported."
    exit 1
fi

# Validate / map devname
mappedDevname=$( $DEVICE_NAME_MAPPER --ext ${DEVNAME} )
if [ $? -ne 0 ]; then
    echo "Error: cannot map deviceID ($DEVNAME)"
    exit 1
fi

read deviceFullId deviceStem deviceIndex <<EOF
${mappedDevname}
EOF

if [ $TEST_RUN -ne 1 ] && [ $VERBOSE -eq 1 ]; then
    dbg "called with $COMMAND $DEVNAME profile ${profile_path}"
    dbg "map result $deviceFullId  and   $deviceStem  and  $deviceIndex"
    dbg "mapped $DEVNAME to $deviceFullId searching $deviceFullId"
fi

profile_i2c_bus=""
profile_i2c_addr=""
profile_i2c_method=""

while IFS=',' read -r dev bus addr method count ignore
do
    dbg "$dev $bus $addr $method $ignore"

    if [ "$dev,," = "$deviceFullId,," ]; then

        if [ $TEST_RUN -ne 1 ] && [ $VERBOSE -eq 1 ]; then
            dbg "MATCH $dev $bus $addr"
        fi

        profile_i2c_bus=$bus
        profile_i2c_addr=$addr
        profile_i2c_method=$method
        profile_i2c_count=1

        if [[ -n "$count" ]]; then
            profile_i2c_count=$count
        fi

        # this is last field in csv and there is unprintable character breaking
        # the logic, removing linebreak fixes the problem
        profile_i2c_method=${profile_i2c_method//$'\r'/''}
        profile_i2c_method=${profile_i2c_method//$'\n'/''}
        break
    fi
done < ${profile_path}

if [ -z "$profile_i2c_bus" ] || [ -z "$profile_i2c_addr" ]; then
    echo "Error: device $deviceFullId not found in $profile_path"
    exit 1
fi

if [ "$profile_i2c_method" = "get" ]; then
    i2cCmd="i2ctransfer -y $profile_i2c_bus w1@$profile_i2c_addr 0x00 r$profile_i2c_count"
elif [ "$profile_i2c_method" = "detect" ]; then
    i2cCmd="i2cdetect -y $profile_i2c_bus"
else
    echo "Error: unsupported method ($profile_i2c_method)"
    exit 1
fi

dbg "$i2cCmd"

if [ $DRY_RUN -eq 1 ]; then
    output="0xaa" # dummy out 
    dbg "dry run, substituting read value with $output"
    rc=0
elif [ $TEST_RUN -eq 1 ]; then
    output=$ARTIFICIAL_OUTPUT
    rc=$ARTIFICIAL_RC_CODE
else
    output=$($i2cCmd 2>&1); rc=$?
fi

if [ $rc -ne 0 ]; then
    output=$(echo $output | tr '[:upper:]' '[:lower:]')
    ERROR=$(echo $output | cut -d ":" -f 1)
    ERROR_MSG=$(echo $output | cut -d ":" -f 2 | sed -e 's/^[[:space:]]*//')
    ERRNO_STR=$(echo $output | cut -d ":" -f 3 | sed -e 's/^[[:space:]]*//')
    ADDITIONAL_OUTPUT="$ERRNO_STR"

    case $ERRNO_STR in
        *"no such file or directory"*)
            rc=2
            ;;
        *"protocol error"*)
            rc=101
            ;;
        *"no such device or address"*)
            rc=2
            ;;
        *"input/output error"*)
            rc=102
            ;;
        *"connection timed out"*)
            rc=103
            ;;
        *"resource temporarily unavailable"*)
            rc=104
            ;;
        *)
            rc=100
            ADDITIONAL_OUTPUT="$output"
            ;;
    esac

    if (( $rc < 100 )); then
        >&2 echo "Error: cmd failed ($i2cCmd) rc=$rc output ($output)"
        exit $rc
    else
        echo "link-down; $ADDITIONAL_OUTPUT"
        exit 0
    fi  
else
    echo "link-up"
    exit 0
fi
